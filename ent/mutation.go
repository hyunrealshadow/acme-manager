// Code generated by ent, DO NOT EDIT.

package ent

import (
	"acme-manager/acme/lego"
	"acme-manager/ent/acmeaccount"
	"acme-manager/ent/acmeserver"
	"acme-manager/ent/certificate"
	"acme-manager/ent/dnsprovider"
	"acme-manager/ent/predicate"
	"acme-manager/ent/schema/enum"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-acme/lego/v4/registration"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAcmeAccount = "AcmeAccount"
	TypeAcmeServer  = "AcmeServer"
	TypeCertificate = "Certificate"
	TypeDnsProvider = "DnsProvider"
)

// AcmeAccountMutation represents an operation that mutates the AcmeAccount nodes in the graph.
type AcmeAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	email               *string
	key_type            *enum.KeyType
	private_key         *string
	key_fingerprint     *string
	registration        *registration.Resource
	eab_key_id          *string
	eab_hmac_key        *string
	created_at          *time.Time
	created_by          *uuid.UUID
	updated_at          *time.Time
	updated_by          *uuid.UUID
	clearedFields       map[string]struct{}
	certificates        map[uuid.UUID]struct{}
	removedcertificates map[uuid.UUID]struct{}
	clearedcertificates bool
	acme_server         *uuid.UUID
	clearedacme_server  bool
	done                bool
	oldValue            func(context.Context) (*AcmeAccount, error)
	predicates          []predicate.AcmeAccount
}

var _ ent.Mutation = (*AcmeAccountMutation)(nil)

// acmeaccountOption allows management of the mutation configuration using functional options.
type acmeaccountOption func(*AcmeAccountMutation)

// newAcmeAccountMutation creates new mutation for the AcmeAccount entity.
func newAcmeAccountMutation(c config, op Op, opts ...acmeaccountOption) *AcmeAccountMutation {
	m := &AcmeAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAcmeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAcmeAccountID sets the ID field of the mutation.
func withAcmeAccountID(id uuid.UUID) acmeaccountOption {
	return func(m *AcmeAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *AcmeAccount
		)
		m.oldValue = func(ctx context.Context) (*AcmeAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AcmeAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAcmeAccount sets the old AcmeAccount of the mutation.
func withAcmeAccount(node *AcmeAccount) acmeaccountOption {
	return func(m *AcmeAccountMutation) {
		m.oldValue = func(context.Context) (*AcmeAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AcmeAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AcmeAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AcmeAccount entities.
func (m *AcmeAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AcmeAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AcmeAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AcmeAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAcmeServerID sets the "acme_server_id" field.
func (m *AcmeAccountMutation) SetAcmeServerID(u uuid.UUID) {
	m.acme_server = &u
}

// AcmeServerID returns the value of the "acme_server_id" field in the mutation.
func (m *AcmeAccountMutation) AcmeServerID() (r uuid.UUID, exists bool) {
	v := m.acme_server
	if v == nil {
		return
	}
	return *v, true
}

// OldAcmeServerID returns the old "acme_server_id" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldAcmeServerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcmeServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcmeServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcmeServerID: %w", err)
	}
	return oldValue.AcmeServerID, nil
}

// ResetAcmeServerID resets all changes to the "acme_server_id" field.
func (m *AcmeAccountMutation) ResetAcmeServerID() {
	m.acme_server = nil
}

// SetName sets the "name" field.
func (m *AcmeAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AcmeAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AcmeAccountMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AcmeAccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AcmeAccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AcmeAccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[acmeaccount.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AcmeAccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[acmeaccount.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AcmeAccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, acmeaccount.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *AcmeAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AcmeAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AcmeAccountMutation) ResetEmail() {
	m.email = nil
}

// SetKeyType sets the "key_type" field.
func (m *AcmeAccountMutation) SetKeyType(et enum.KeyType) {
	m.key_type = &et
}

// KeyType returns the value of the "key_type" field in the mutation.
func (m *AcmeAccountMutation) KeyType() (r enum.KeyType, exists bool) {
	v := m.key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyType returns the old "key_type" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldKeyType(ctx context.Context) (v enum.KeyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyType: %w", err)
	}
	return oldValue.KeyType, nil
}

// ResetKeyType resets all changes to the "key_type" field.
func (m *AcmeAccountMutation) ResetKeyType() {
	m.key_type = nil
}

// SetPrivateKey sets the "private_key" field.
func (m *AcmeAccountMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *AcmeAccountMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *AcmeAccountMutation) ResetPrivateKey() {
	m.private_key = nil
}

// SetKeyFingerprint sets the "key_fingerprint" field.
func (m *AcmeAccountMutation) SetKeyFingerprint(s string) {
	m.key_fingerprint = &s
}

// KeyFingerprint returns the value of the "key_fingerprint" field in the mutation.
func (m *AcmeAccountMutation) KeyFingerprint() (r string, exists bool) {
	v := m.key_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyFingerprint returns the old "key_fingerprint" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldKeyFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyFingerprint: %w", err)
	}
	return oldValue.KeyFingerprint, nil
}

// ResetKeyFingerprint resets all changes to the "key_fingerprint" field.
func (m *AcmeAccountMutation) ResetKeyFingerprint() {
	m.key_fingerprint = nil
}

// SetRegistration sets the "registration" field.
func (m *AcmeAccountMutation) SetRegistration(r registration.Resource) {
	m.registration = &r
}

// Registration returns the value of the "registration" field in the mutation.
func (m *AcmeAccountMutation) Registration() (r registration.Resource, exists bool) {
	v := m.registration
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistration returns the old "registration" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldRegistration(ctx context.Context) (v registration.Resource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistration: %w", err)
	}
	return oldValue.Registration, nil
}

// ResetRegistration resets all changes to the "registration" field.
func (m *AcmeAccountMutation) ResetRegistration() {
	m.registration = nil
}

// SetEabKeyID sets the "eab_key_id" field.
func (m *AcmeAccountMutation) SetEabKeyID(s string) {
	m.eab_key_id = &s
}

// EabKeyID returns the value of the "eab_key_id" field in the mutation.
func (m *AcmeAccountMutation) EabKeyID() (r string, exists bool) {
	v := m.eab_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEabKeyID returns the old "eab_key_id" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldEabKeyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEabKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEabKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEabKeyID: %w", err)
	}
	return oldValue.EabKeyID, nil
}

// ClearEabKeyID clears the value of the "eab_key_id" field.
func (m *AcmeAccountMutation) ClearEabKeyID() {
	m.eab_key_id = nil
	m.clearedFields[acmeaccount.FieldEabKeyID] = struct{}{}
}

// EabKeyIDCleared returns if the "eab_key_id" field was cleared in this mutation.
func (m *AcmeAccountMutation) EabKeyIDCleared() bool {
	_, ok := m.clearedFields[acmeaccount.FieldEabKeyID]
	return ok
}

// ResetEabKeyID resets all changes to the "eab_key_id" field.
func (m *AcmeAccountMutation) ResetEabKeyID() {
	m.eab_key_id = nil
	delete(m.clearedFields, acmeaccount.FieldEabKeyID)
}

// SetEabHmacKey sets the "eab_hmac_key" field.
func (m *AcmeAccountMutation) SetEabHmacKey(s string) {
	m.eab_hmac_key = &s
}

// EabHmacKey returns the value of the "eab_hmac_key" field in the mutation.
func (m *AcmeAccountMutation) EabHmacKey() (r string, exists bool) {
	v := m.eab_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEabHmacKey returns the old "eab_hmac_key" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldEabHmacKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEabHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEabHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEabHmacKey: %w", err)
	}
	return oldValue.EabHmacKey, nil
}

// ClearEabHmacKey clears the value of the "eab_hmac_key" field.
func (m *AcmeAccountMutation) ClearEabHmacKey() {
	m.eab_hmac_key = nil
	m.clearedFields[acmeaccount.FieldEabHmacKey] = struct{}{}
}

// EabHmacKeyCleared returns if the "eab_hmac_key" field was cleared in this mutation.
func (m *AcmeAccountMutation) EabHmacKeyCleared() bool {
	_, ok := m.clearedFields[acmeaccount.FieldEabHmacKey]
	return ok
}

// ResetEabHmacKey resets all changes to the "eab_hmac_key" field.
func (m *AcmeAccountMutation) ResetEabHmacKey() {
	m.eab_hmac_key = nil
	delete(m.clearedFields, acmeaccount.FieldEabHmacKey)
}

// SetCreatedAt sets the "created_at" field.
func (m *AcmeAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AcmeAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AcmeAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AcmeAccountMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AcmeAccountMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AcmeAccountMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AcmeAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AcmeAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AcmeAccountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[acmeaccount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AcmeAccountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[acmeaccount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AcmeAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, acmeaccount.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AcmeAccountMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AcmeAccountMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AcmeAccount entity.
// If the AcmeAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeAccountMutation) OldUpdatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AcmeAccountMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[acmeaccount.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AcmeAccountMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[acmeaccount.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AcmeAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, acmeaccount.FieldUpdatedBy)
}

// AddCertificateIDs adds the "certificates" edge to the Certificate entity by ids.
func (m *AcmeAccountMutation) AddCertificateIDs(ids ...uuid.UUID) {
	if m.certificates == nil {
		m.certificates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certificates[ids[i]] = struct{}{}
	}
}

// ClearCertificates clears the "certificates" edge to the Certificate entity.
func (m *AcmeAccountMutation) ClearCertificates() {
	m.clearedcertificates = true
}

// CertificatesCleared reports if the "certificates" edge to the Certificate entity was cleared.
func (m *AcmeAccountMutation) CertificatesCleared() bool {
	return m.clearedcertificates
}

// RemoveCertificateIDs removes the "certificates" edge to the Certificate entity by IDs.
func (m *AcmeAccountMutation) RemoveCertificateIDs(ids ...uuid.UUID) {
	if m.removedcertificates == nil {
		m.removedcertificates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certificates, ids[i])
		m.removedcertificates[ids[i]] = struct{}{}
	}
}

// RemovedCertificates returns the removed IDs of the "certificates" edge to the Certificate entity.
func (m *AcmeAccountMutation) RemovedCertificatesIDs() (ids []uuid.UUID) {
	for id := range m.removedcertificates {
		ids = append(ids, id)
	}
	return
}

// CertificatesIDs returns the "certificates" edge IDs in the mutation.
func (m *AcmeAccountMutation) CertificatesIDs() (ids []uuid.UUID) {
	for id := range m.certificates {
		ids = append(ids, id)
	}
	return
}

// ResetCertificates resets all changes to the "certificates" edge.
func (m *AcmeAccountMutation) ResetCertificates() {
	m.certificates = nil
	m.clearedcertificates = false
	m.removedcertificates = nil
}

// ClearAcmeServer clears the "acme_server" edge to the AcmeServer entity.
func (m *AcmeAccountMutation) ClearAcmeServer() {
	m.clearedacme_server = true
	m.clearedFields[acmeaccount.FieldAcmeServerID] = struct{}{}
}

// AcmeServerCleared reports if the "acme_server" edge to the AcmeServer entity was cleared.
func (m *AcmeAccountMutation) AcmeServerCleared() bool {
	return m.clearedacme_server
}

// AcmeServerIDs returns the "acme_server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AcmeServerID instead. It exists only for internal usage by the builders.
func (m *AcmeAccountMutation) AcmeServerIDs() (ids []uuid.UUID) {
	if id := m.acme_server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAcmeServer resets all changes to the "acme_server" edge.
func (m *AcmeAccountMutation) ResetAcmeServer() {
	m.acme_server = nil
	m.clearedacme_server = false
}

// Where appends a list predicates to the AcmeAccountMutation builder.
func (m *AcmeAccountMutation) Where(ps ...predicate.AcmeAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AcmeAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AcmeAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AcmeAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AcmeAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AcmeAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AcmeAccount).
func (m *AcmeAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AcmeAccountMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.acme_server != nil {
		fields = append(fields, acmeaccount.FieldAcmeServerID)
	}
	if m.name != nil {
		fields = append(fields, acmeaccount.FieldName)
	}
	if m.description != nil {
		fields = append(fields, acmeaccount.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, acmeaccount.FieldEmail)
	}
	if m.key_type != nil {
		fields = append(fields, acmeaccount.FieldKeyType)
	}
	if m.private_key != nil {
		fields = append(fields, acmeaccount.FieldPrivateKey)
	}
	if m.key_fingerprint != nil {
		fields = append(fields, acmeaccount.FieldKeyFingerprint)
	}
	if m.registration != nil {
		fields = append(fields, acmeaccount.FieldRegistration)
	}
	if m.eab_key_id != nil {
		fields = append(fields, acmeaccount.FieldEabKeyID)
	}
	if m.eab_hmac_key != nil {
		fields = append(fields, acmeaccount.FieldEabHmacKey)
	}
	if m.created_at != nil {
		fields = append(fields, acmeaccount.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, acmeaccount.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, acmeaccount.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, acmeaccount.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AcmeAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case acmeaccount.FieldAcmeServerID:
		return m.AcmeServerID()
	case acmeaccount.FieldName:
		return m.Name()
	case acmeaccount.FieldDescription:
		return m.Description()
	case acmeaccount.FieldEmail:
		return m.Email()
	case acmeaccount.FieldKeyType:
		return m.KeyType()
	case acmeaccount.FieldPrivateKey:
		return m.PrivateKey()
	case acmeaccount.FieldKeyFingerprint:
		return m.KeyFingerprint()
	case acmeaccount.FieldRegistration:
		return m.Registration()
	case acmeaccount.FieldEabKeyID:
		return m.EabKeyID()
	case acmeaccount.FieldEabHmacKey:
		return m.EabHmacKey()
	case acmeaccount.FieldCreatedAt:
		return m.CreatedAt()
	case acmeaccount.FieldCreatedBy:
		return m.CreatedBy()
	case acmeaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case acmeaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AcmeAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case acmeaccount.FieldAcmeServerID:
		return m.OldAcmeServerID(ctx)
	case acmeaccount.FieldName:
		return m.OldName(ctx)
	case acmeaccount.FieldDescription:
		return m.OldDescription(ctx)
	case acmeaccount.FieldEmail:
		return m.OldEmail(ctx)
	case acmeaccount.FieldKeyType:
		return m.OldKeyType(ctx)
	case acmeaccount.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case acmeaccount.FieldKeyFingerprint:
		return m.OldKeyFingerprint(ctx)
	case acmeaccount.FieldRegistration:
		return m.OldRegistration(ctx)
	case acmeaccount.FieldEabKeyID:
		return m.OldEabKeyID(ctx)
	case acmeaccount.FieldEabHmacKey:
		return m.OldEabHmacKey(ctx)
	case acmeaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case acmeaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case acmeaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case acmeaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown AcmeAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case acmeaccount.FieldAcmeServerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcmeServerID(v)
		return nil
	case acmeaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case acmeaccount.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case acmeaccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case acmeaccount.FieldKeyType:
		v, ok := value.(enum.KeyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyType(v)
		return nil
	case acmeaccount.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case acmeaccount.FieldKeyFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyFingerprint(v)
		return nil
	case acmeaccount.FieldRegistration:
		v, ok := value.(registration.Resource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistration(v)
		return nil
	case acmeaccount.FieldEabKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEabKeyID(v)
		return nil
	case acmeaccount.FieldEabHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEabHmacKey(v)
		return nil
	case acmeaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case acmeaccount.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case acmeaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case acmeaccount.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AcmeAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AcmeAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AcmeAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AcmeAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AcmeAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(acmeaccount.FieldDescription) {
		fields = append(fields, acmeaccount.FieldDescription)
	}
	if m.FieldCleared(acmeaccount.FieldEabKeyID) {
		fields = append(fields, acmeaccount.FieldEabKeyID)
	}
	if m.FieldCleared(acmeaccount.FieldEabHmacKey) {
		fields = append(fields, acmeaccount.FieldEabHmacKey)
	}
	if m.FieldCleared(acmeaccount.FieldUpdatedAt) {
		fields = append(fields, acmeaccount.FieldUpdatedAt)
	}
	if m.FieldCleared(acmeaccount.FieldUpdatedBy) {
		fields = append(fields, acmeaccount.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AcmeAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AcmeAccountMutation) ClearField(name string) error {
	switch name {
	case acmeaccount.FieldDescription:
		m.ClearDescription()
		return nil
	case acmeaccount.FieldEabKeyID:
		m.ClearEabKeyID()
		return nil
	case acmeaccount.FieldEabHmacKey:
		m.ClearEabHmacKey()
		return nil
	case acmeaccount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case acmeaccount.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AcmeAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AcmeAccountMutation) ResetField(name string) error {
	switch name {
	case acmeaccount.FieldAcmeServerID:
		m.ResetAcmeServerID()
		return nil
	case acmeaccount.FieldName:
		m.ResetName()
		return nil
	case acmeaccount.FieldDescription:
		m.ResetDescription()
		return nil
	case acmeaccount.FieldEmail:
		m.ResetEmail()
		return nil
	case acmeaccount.FieldKeyType:
		m.ResetKeyType()
		return nil
	case acmeaccount.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case acmeaccount.FieldKeyFingerprint:
		m.ResetKeyFingerprint()
		return nil
	case acmeaccount.FieldRegistration:
		m.ResetRegistration()
		return nil
	case acmeaccount.FieldEabKeyID:
		m.ResetEabKeyID()
		return nil
	case acmeaccount.FieldEabHmacKey:
		m.ResetEabHmacKey()
		return nil
	case acmeaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case acmeaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case acmeaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case acmeaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AcmeAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AcmeAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.certificates != nil {
		edges = append(edges, acmeaccount.EdgeCertificates)
	}
	if m.acme_server != nil {
		edges = append(edges, acmeaccount.EdgeAcmeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AcmeAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case acmeaccount.EdgeCertificates:
		ids := make([]ent.Value, 0, len(m.certificates))
		for id := range m.certificates {
			ids = append(ids, id)
		}
		return ids
	case acmeaccount.EdgeAcmeServer:
		if id := m.acme_server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AcmeAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcertificates != nil {
		edges = append(edges, acmeaccount.EdgeCertificates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AcmeAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case acmeaccount.EdgeCertificates:
		ids := make([]ent.Value, 0, len(m.removedcertificates))
		for id := range m.removedcertificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AcmeAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcertificates {
		edges = append(edges, acmeaccount.EdgeCertificates)
	}
	if m.clearedacme_server {
		edges = append(edges, acmeaccount.EdgeAcmeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AcmeAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case acmeaccount.EdgeCertificates:
		return m.clearedcertificates
	case acmeaccount.EdgeAcmeServer:
		return m.clearedacme_server
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AcmeAccountMutation) ClearEdge(name string) error {
	switch name {
	case acmeaccount.EdgeAcmeServer:
		m.ClearAcmeServer()
		return nil
	}
	return fmt.Errorf("unknown AcmeAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AcmeAccountMutation) ResetEdge(name string) error {
	switch name {
	case acmeaccount.EdgeCertificates:
		m.ResetCertificates()
		return nil
	case acmeaccount.EdgeAcmeServer:
		m.ResetAcmeServer()
		return nil
	}
	return fmt.Errorf("unknown AcmeAccount edge %s", name)
}

// AcmeServerMutation represents an operation that mutates the AcmeServer nodes in the graph.
type AcmeServerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	name                      *string
	description               *string
	url                       *string
	built_in                  *bool
	external_account_required *bool
	created_at                *time.Time
	created_by                *uuid.UUID
	updated_at                *time.Time
	updated_by                *uuid.UUID
	clearedFields             map[string]struct{}
	acme_accounts             map[uuid.UUID]struct{}
	removedacme_accounts      map[uuid.UUID]struct{}
	clearedacme_accounts      bool
	done                      bool
	oldValue                  func(context.Context) (*AcmeServer, error)
	predicates                []predicate.AcmeServer
}

var _ ent.Mutation = (*AcmeServerMutation)(nil)

// acmeserverOption allows management of the mutation configuration using functional options.
type acmeserverOption func(*AcmeServerMutation)

// newAcmeServerMutation creates new mutation for the AcmeServer entity.
func newAcmeServerMutation(c config, op Op, opts ...acmeserverOption) *AcmeServerMutation {
	m := &AcmeServerMutation{
		config:        c,
		op:            op,
		typ:           TypeAcmeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAcmeServerID sets the ID field of the mutation.
func withAcmeServerID(id uuid.UUID) acmeserverOption {
	return func(m *AcmeServerMutation) {
		var (
			err   error
			once  sync.Once
			value *AcmeServer
		)
		m.oldValue = func(ctx context.Context) (*AcmeServer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AcmeServer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAcmeServer sets the old AcmeServer of the mutation.
func withAcmeServer(node *AcmeServer) acmeserverOption {
	return func(m *AcmeServerMutation) {
		m.oldValue = func(context.Context) (*AcmeServer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AcmeServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AcmeServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AcmeServer entities.
func (m *AcmeServerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AcmeServerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AcmeServerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AcmeServer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AcmeServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AcmeServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AcmeServerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AcmeServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AcmeServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AcmeServerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[acmeserver.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AcmeServerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[acmeserver.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AcmeServerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, acmeserver.FieldDescription)
}

// SetURL sets the "url" field.
func (m *AcmeServerMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AcmeServerMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AcmeServerMutation) ResetURL() {
	m.url = nil
}

// SetBuiltIn sets the "built_in" field.
func (m *AcmeServerMutation) SetBuiltIn(b bool) {
	m.built_in = &b
}

// BuiltIn returns the value of the "built_in" field in the mutation.
func (m *AcmeServerMutation) BuiltIn() (r bool, exists bool) {
	v := m.built_in
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltIn returns the old "built_in" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldBuiltIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltIn: %w", err)
	}
	return oldValue.BuiltIn, nil
}

// ResetBuiltIn resets all changes to the "built_in" field.
func (m *AcmeServerMutation) ResetBuiltIn() {
	m.built_in = nil
}

// SetExternalAccountRequired sets the "external_account_required" field.
func (m *AcmeServerMutation) SetExternalAccountRequired(b bool) {
	m.external_account_required = &b
}

// ExternalAccountRequired returns the value of the "external_account_required" field in the mutation.
func (m *AcmeServerMutation) ExternalAccountRequired() (r bool, exists bool) {
	v := m.external_account_required
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalAccountRequired returns the old "external_account_required" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldExternalAccountRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalAccountRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalAccountRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalAccountRequired: %w", err)
	}
	return oldValue.ExternalAccountRequired, nil
}

// ResetExternalAccountRequired resets all changes to the "external_account_required" field.
func (m *AcmeServerMutation) ResetExternalAccountRequired() {
	m.external_account_required = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AcmeServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AcmeServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AcmeServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AcmeServerMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AcmeServerMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AcmeServerMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AcmeServerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AcmeServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AcmeServerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[acmeserver.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AcmeServerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[acmeserver.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AcmeServerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, acmeserver.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AcmeServerMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AcmeServerMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AcmeServer entity.
// If the AcmeServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeServerMutation) OldUpdatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AcmeServerMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[acmeserver.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AcmeServerMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[acmeserver.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AcmeServerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, acmeserver.FieldUpdatedBy)
}

// AddAcmeAccountIDs adds the "acme_accounts" edge to the AcmeAccount entity by ids.
func (m *AcmeServerMutation) AddAcmeAccountIDs(ids ...uuid.UUID) {
	if m.acme_accounts == nil {
		m.acme_accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.acme_accounts[ids[i]] = struct{}{}
	}
}

// ClearAcmeAccounts clears the "acme_accounts" edge to the AcmeAccount entity.
func (m *AcmeServerMutation) ClearAcmeAccounts() {
	m.clearedacme_accounts = true
}

// AcmeAccountsCleared reports if the "acme_accounts" edge to the AcmeAccount entity was cleared.
func (m *AcmeServerMutation) AcmeAccountsCleared() bool {
	return m.clearedacme_accounts
}

// RemoveAcmeAccountIDs removes the "acme_accounts" edge to the AcmeAccount entity by IDs.
func (m *AcmeServerMutation) RemoveAcmeAccountIDs(ids ...uuid.UUID) {
	if m.removedacme_accounts == nil {
		m.removedacme_accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.acme_accounts, ids[i])
		m.removedacme_accounts[ids[i]] = struct{}{}
	}
}

// RemovedAcmeAccounts returns the removed IDs of the "acme_accounts" edge to the AcmeAccount entity.
func (m *AcmeServerMutation) RemovedAcmeAccountsIDs() (ids []uuid.UUID) {
	for id := range m.removedacme_accounts {
		ids = append(ids, id)
	}
	return
}

// AcmeAccountsIDs returns the "acme_accounts" edge IDs in the mutation.
func (m *AcmeServerMutation) AcmeAccountsIDs() (ids []uuid.UUID) {
	for id := range m.acme_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAcmeAccounts resets all changes to the "acme_accounts" edge.
func (m *AcmeServerMutation) ResetAcmeAccounts() {
	m.acme_accounts = nil
	m.clearedacme_accounts = false
	m.removedacme_accounts = nil
}

// Where appends a list predicates to the AcmeServerMutation builder.
func (m *AcmeServerMutation) Where(ps ...predicate.AcmeServer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AcmeServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AcmeServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AcmeServer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AcmeServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AcmeServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AcmeServer).
func (m *AcmeServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AcmeServerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, acmeserver.FieldName)
	}
	if m.description != nil {
		fields = append(fields, acmeserver.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, acmeserver.FieldURL)
	}
	if m.built_in != nil {
		fields = append(fields, acmeserver.FieldBuiltIn)
	}
	if m.external_account_required != nil {
		fields = append(fields, acmeserver.FieldExternalAccountRequired)
	}
	if m.created_at != nil {
		fields = append(fields, acmeserver.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, acmeserver.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, acmeserver.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, acmeserver.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AcmeServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case acmeserver.FieldName:
		return m.Name()
	case acmeserver.FieldDescription:
		return m.Description()
	case acmeserver.FieldURL:
		return m.URL()
	case acmeserver.FieldBuiltIn:
		return m.BuiltIn()
	case acmeserver.FieldExternalAccountRequired:
		return m.ExternalAccountRequired()
	case acmeserver.FieldCreatedAt:
		return m.CreatedAt()
	case acmeserver.FieldCreatedBy:
		return m.CreatedBy()
	case acmeserver.FieldUpdatedAt:
		return m.UpdatedAt()
	case acmeserver.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AcmeServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case acmeserver.FieldName:
		return m.OldName(ctx)
	case acmeserver.FieldDescription:
		return m.OldDescription(ctx)
	case acmeserver.FieldURL:
		return m.OldURL(ctx)
	case acmeserver.FieldBuiltIn:
		return m.OldBuiltIn(ctx)
	case acmeserver.FieldExternalAccountRequired:
		return m.OldExternalAccountRequired(ctx)
	case acmeserver.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case acmeserver.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case acmeserver.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case acmeserver.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown AcmeServer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case acmeserver.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case acmeserver.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case acmeserver.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case acmeserver.FieldBuiltIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltIn(v)
		return nil
	case acmeserver.FieldExternalAccountRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalAccountRequired(v)
		return nil
	case acmeserver.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case acmeserver.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case acmeserver.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case acmeserver.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AcmeServer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AcmeServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AcmeServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AcmeServer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AcmeServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(acmeserver.FieldDescription) {
		fields = append(fields, acmeserver.FieldDescription)
	}
	if m.FieldCleared(acmeserver.FieldUpdatedAt) {
		fields = append(fields, acmeserver.FieldUpdatedAt)
	}
	if m.FieldCleared(acmeserver.FieldUpdatedBy) {
		fields = append(fields, acmeserver.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AcmeServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AcmeServerMutation) ClearField(name string) error {
	switch name {
	case acmeserver.FieldDescription:
		m.ClearDescription()
		return nil
	case acmeserver.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case acmeserver.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AcmeServer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AcmeServerMutation) ResetField(name string) error {
	switch name {
	case acmeserver.FieldName:
		m.ResetName()
		return nil
	case acmeserver.FieldDescription:
		m.ResetDescription()
		return nil
	case acmeserver.FieldURL:
		m.ResetURL()
		return nil
	case acmeserver.FieldBuiltIn:
		m.ResetBuiltIn()
		return nil
	case acmeserver.FieldExternalAccountRequired:
		m.ResetExternalAccountRequired()
		return nil
	case acmeserver.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case acmeserver.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case acmeserver.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case acmeserver.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AcmeServer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AcmeServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.acme_accounts != nil {
		edges = append(edges, acmeserver.EdgeAcmeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AcmeServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case acmeserver.EdgeAcmeAccounts:
		ids := make([]ent.Value, 0, len(m.acme_accounts))
		for id := range m.acme_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AcmeServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedacme_accounts != nil {
		edges = append(edges, acmeserver.EdgeAcmeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AcmeServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case acmeserver.EdgeAcmeAccounts:
		ids := make([]ent.Value, 0, len(m.removedacme_accounts))
		for id := range m.removedacme_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AcmeServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedacme_accounts {
		edges = append(edges, acmeserver.EdgeAcmeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AcmeServerMutation) EdgeCleared(name string) bool {
	switch name {
	case acmeserver.EdgeAcmeAccounts:
		return m.clearedacme_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AcmeServerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AcmeServer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AcmeServerMutation) ResetEdge(name string) error {
	switch name {
	case acmeserver.EdgeAcmeAccounts:
		m.ResetAcmeAccounts()
		return nil
	}
	return fmt.Errorf("unknown AcmeServer edge %s", name)
}

// CertificateMutation represents an operation that mutates the Certificate nodes in the graph.
type CertificateMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	common_name                    *string
	subject_alternative_name       *[]string
	appendsubject_alternative_name []string
	organization                   *string
	organizational_unit            *string
	country                        *string
	state                          *string
	locality                       *string
	street_address                 *string
	key_type                       *enum.KeyType
	csr                            *string
	private_key                    *string
	certificate                    *string
	certificate_chain              *[]string
	appendcertificate_chain        []string
	fingerprint                    *string
	status                         *enum.Status
	issued_at                      *time.Time
	expires_at                     *time.Time
	created_at                     *time.Time
	created_by                     *uuid.UUID
	updated_at                     *time.Time
	updated_by                     *uuid.UUID
	clearedFields                  map[string]struct{}
	acme_account                   *uuid.UUID
	clearedacme_account            bool
	dns_provider                   *uuid.UUID
	cleareddns_provider            bool
	done                           bool
	oldValue                       func(context.Context) (*Certificate, error)
	predicates                     []predicate.Certificate
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows management of the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for the Certificate entity.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the ID field of the mutation.
func withCertificateID(id uuid.UUID) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Certificate entities.
func (m *CertificateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAcmeAccountID sets the "acme_account_id" field.
func (m *CertificateMutation) SetAcmeAccountID(u uuid.UUID) {
	m.acme_account = &u
}

// AcmeAccountID returns the value of the "acme_account_id" field in the mutation.
func (m *CertificateMutation) AcmeAccountID() (r uuid.UUID, exists bool) {
	v := m.acme_account
	if v == nil {
		return
	}
	return *v, true
}

// OldAcmeAccountID returns the old "acme_account_id" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldAcmeAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcmeAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcmeAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcmeAccountID: %w", err)
	}
	return oldValue.AcmeAccountID, nil
}

// ResetAcmeAccountID resets all changes to the "acme_account_id" field.
func (m *CertificateMutation) ResetAcmeAccountID() {
	m.acme_account = nil
}

// SetDNSProviderID sets the "dns_provider_id" field.
func (m *CertificateMutation) SetDNSProviderID(u uuid.UUID) {
	m.dns_provider = &u
}

// DNSProviderID returns the value of the "dns_provider_id" field in the mutation.
func (m *CertificateMutation) DNSProviderID() (r uuid.UUID, exists bool) {
	v := m.dns_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSProviderID returns the old "dns_provider_id" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldDNSProviderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSProviderID: %w", err)
	}
	return oldValue.DNSProviderID, nil
}

// ResetDNSProviderID resets all changes to the "dns_provider_id" field.
func (m *CertificateMutation) ResetDNSProviderID() {
	m.dns_provider = nil
}

// SetCommonName sets the "common_name" field.
func (m *CertificateMutation) SetCommonName(s string) {
	m.common_name = &s
}

// CommonName returns the value of the "common_name" field in the mutation.
func (m *CertificateMutation) CommonName() (r string, exists bool) {
	v := m.common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonName returns the old "common_name" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonName: %w", err)
	}
	return oldValue.CommonName, nil
}

// ResetCommonName resets all changes to the "common_name" field.
func (m *CertificateMutation) ResetCommonName() {
	m.common_name = nil
}

// SetSubjectAlternativeName sets the "subject_alternative_name" field.
func (m *CertificateMutation) SetSubjectAlternativeName(s []string) {
	m.subject_alternative_name = &s
	m.appendsubject_alternative_name = nil
}

// SubjectAlternativeName returns the value of the "subject_alternative_name" field in the mutation.
func (m *CertificateMutation) SubjectAlternativeName() (r []string, exists bool) {
	v := m.subject_alternative_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectAlternativeName returns the old "subject_alternative_name" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldSubjectAlternativeName(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectAlternativeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectAlternativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectAlternativeName: %w", err)
	}
	return oldValue.SubjectAlternativeName, nil
}

// AppendSubjectAlternativeName adds s to the "subject_alternative_name" field.
func (m *CertificateMutation) AppendSubjectAlternativeName(s []string) {
	m.appendsubject_alternative_name = append(m.appendsubject_alternative_name, s...)
}

// AppendedSubjectAlternativeName returns the list of values that were appended to the "subject_alternative_name" field in this mutation.
func (m *CertificateMutation) AppendedSubjectAlternativeName() ([]string, bool) {
	if len(m.appendsubject_alternative_name) == 0 {
		return nil, false
	}
	return m.appendsubject_alternative_name, true
}

// ClearSubjectAlternativeName clears the value of the "subject_alternative_name" field.
func (m *CertificateMutation) ClearSubjectAlternativeName() {
	m.subject_alternative_name = nil
	m.appendsubject_alternative_name = nil
	m.clearedFields[certificate.FieldSubjectAlternativeName] = struct{}{}
}

// SubjectAlternativeNameCleared returns if the "subject_alternative_name" field was cleared in this mutation.
func (m *CertificateMutation) SubjectAlternativeNameCleared() bool {
	_, ok := m.clearedFields[certificate.FieldSubjectAlternativeName]
	return ok
}

// ResetSubjectAlternativeName resets all changes to the "subject_alternative_name" field.
func (m *CertificateMutation) ResetSubjectAlternativeName() {
	m.subject_alternative_name = nil
	m.appendsubject_alternative_name = nil
	delete(m.clearedFields, certificate.FieldSubjectAlternativeName)
}

// SetOrganization sets the "organization" field.
func (m *CertificateMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *CertificateMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldOrganization(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *CertificateMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[certificate.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *CertificateMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[certificate.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *CertificateMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, certificate.FieldOrganization)
}

// SetOrganizationalUnit sets the "organizational_unit" field.
func (m *CertificateMutation) SetOrganizationalUnit(s string) {
	m.organizational_unit = &s
}

// OrganizationalUnit returns the value of the "organizational_unit" field in the mutation.
func (m *CertificateMutation) OrganizationalUnit() (r string, exists bool) {
	v := m.organizational_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationalUnit returns the old "organizational_unit" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldOrganizationalUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationalUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationalUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationalUnit: %w", err)
	}
	return oldValue.OrganizationalUnit, nil
}

// ClearOrganizationalUnit clears the value of the "organizational_unit" field.
func (m *CertificateMutation) ClearOrganizationalUnit() {
	m.organizational_unit = nil
	m.clearedFields[certificate.FieldOrganizationalUnit] = struct{}{}
}

// OrganizationalUnitCleared returns if the "organizational_unit" field was cleared in this mutation.
func (m *CertificateMutation) OrganizationalUnitCleared() bool {
	_, ok := m.clearedFields[certificate.FieldOrganizationalUnit]
	return ok
}

// ResetOrganizationalUnit resets all changes to the "organizational_unit" field.
func (m *CertificateMutation) ResetOrganizationalUnit() {
	m.organizational_unit = nil
	delete(m.clearedFields, certificate.FieldOrganizationalUnit)
}

// SetCountry sets the "country" field.
func (m *CertificateMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CertificateMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *CertificateMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[certificate.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *CertificateMutation) CountryCleared() bool {
	_, ok := m.clearedFields[certificate.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *CertificateMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, certificate.FieldCountry)
}

// SetState sets the "state" field.
func (m *CertificateMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *CertificateMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *CertificateMutation) ClearState() {
	m.state = nil
	m.clearedFields[certificate.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *CertificateMutation) StateCleared() bool {
	_, ok := m.clearedFields[certificate.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *CertificateMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, certificate.FieldState)
}

// SetLocality sets the "locality" field.
func (m *CertificateMutation) SetLocality(s string) {
	m.locality = &s
}

// Locality returns the value of the "locality" field in the mutation.
func (m *CertificateMutation) Locality() (r string, exists bool) {
	v := m.locality
	if v == nil {
		return
	}
	return *v, true
}

// OldLocality returns the old "locality" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldLocality(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocality: %w", err)
	}
	return oldValue.Locality, nil
}

// ClearLocality clears the value of the "locality" field.
func (m *CertificateMutation) ClearLocality() {
	m.locality = nil
	m.clearedFields[certificate.FieldLocality] = struct{}{}
}

// LocalityCleared returns if the "locality" field was cleared in this mutation.
func (m *CertificateMutation) LocalityCleared() bool {
	_, ok := m.clearedFields[certificate.FieldLocality]
	return ok
}

// ResetLocality resets all changes to the "locality" field.
func (m *CertificateMutation) ResetLocality() {
	m.locality = nil
	delete(m.clearedFields, certificate.FieldLocality)
}

// SetStreetAddress sets the "street_address" field.
func (m *CertificateMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *CertificateMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldStreetAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ClearStreetAddress clears the value of the "street_address" field.
func (m *CertificateMutation) ClearStreetAddress() {
	m.street_address = nil
	m.clearedFields[certificate.FieldStreetAddress] = struct{}{}
}

// StreetAddressCleared returns if the "street_address" field was cleared in this mutation.
func (m *CertificateMutation) StreetAddressCleared() bool {
	_, ok := m.clearedFields[certificate.FieldStreetAddress]
	return ok
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *CertificateMutation) ResetStreetAddress() {
	m.street_address = nil
	delete(m.clearedFields, certificate.FieldStreetAddress)
}

// SetKeyType sets the "key_type" field.
func (m *CertificateMutation) SetKeyType(et enum.KeyType) {
	m.key_type = &et
}

// KeyType returns the value of the "key_type" field in the mutation.
func (m *CertificateMutation) KeyType() (r enum.KeyType, exists bool) {
	v := m.key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyType returns the old "key_type" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldKeyType(ctx context.Context) (v enum.KeyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyType: %w", err)
	}
	return oldValue.KeyType, nil
}

// ResetKeyType resets all changes to the "key_type" field.
func (m *CertificateMutation) ResetKeyType() {
	m.key_type = nil
}

// SetCsr sets the "csr" field.
func (m *CertificateMutation) SetCsr(s string) {
	m.csr = &s
}

// Csr returns the value of the "csr" field in the mutation.
func (m *CertificateMutation) Csr() (r string, exists bool) {
	v := m.csr
	if v == nil {
		return
	}
	return *v, true
}

// OldCsr returns the old "csr" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCsr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsr: %w", err)
	}
	return oldValue.Csr, nil
}

// ClearCsr clears the value of the "csr" field.
func (m *CertificateMutation) ClearCsr() {
	m.csr = nil
	m.clearedFields[certificate.FieldCsr] = struct{}{}
}

// CsrCleared returns if the "csr" field was cleared in this mutation.
func (m *CertificateMutation) CsrCleared() bool {
	_, ok := m.clearedFields[certificate.FieldCsr]
	return ok
}

// ResetCsr resets all changes to the "csr" field.
func (m *CertificateMutation) ResetCsr() {
	m.csr = nil
	delete(m.clearedFields, certificate.FieldCsr)
}

// SetPrivateKey sets the "private_key" field.
func (m *CertificateMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *CertificateMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldPrivateKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "private_key" field.
func (m *CertificateMutation) ClearPrivateKey() {
	m.private_key = nil
	m.clearedFields[certificate.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "private_key" field was cleared in this mutation.
func (m *CertificateMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[certificate.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *CertificateMutation) ResetPrivateKey() {
	m.private_key = nil
	delete(m.clearedFields, certificate.FieldPrivateKey)
}

// SetCertificate sets the "certificate" field.
func (m *CertificateMutation) SetCertificate(s string) {
	m.certificate = &s
}

// Certificate returns the value of the "certificate" field in the mutation.
func (m *CertificateMutation) Certificate() (r string, exists bool) {
	v := m.certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificate returns the old "certificate" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificate: %w", err)
	}
	return oldValue.Certificate, nil
}

// ClearCertificate clears the value of the "certificate" field.
func (m *CertificateMutation) ClearCertificate() {
	m.certificate = nil
	m.clearedFields[certificate.FieldCertificate] = struct{}{}
}

// CertificateCleared returns if the "certificate" field was cleared in this mutation.
func (m *CertificateMutation) CertificateCleared() bool {
	_, ok := m.clearedFields[certificate.FieldCertificate]
	return ok
}

// ResetCertificate resets all changes to the "certificate" field.
func (m *CertificateMutation) ResetCertificate() {
	m.certificate = nil
	delete(m.clearedFields, certificate.FieldCertificate)
}

// SetCertificateChain sets the "certificate_chain" field.
func (m *CertificateMutation) SetCertificateChain(s []string) {
	m.certificate_chain = &s
	m.appendcertificate_chain = nil
}

// CertificateChain returns the value of the "certificate_chain" field in the mutation.
func (m *CertificateMutation) CertificateChain() (r []string, exists bool) {
	v := m.certificate_chain
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateChain returns the old "certificate_chain" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificateChain(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateChain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateChain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateChain: %w", err)
	}
	return oldValue.CertificateChain, nil
}

// AppendCertificateChain adds s to the "certificate_chain" field.
func (m *CertificateMutation) AppendCertificateChain(s []string) {
	m.appendcertificate_chain = append(m.appendcertificate_chain, s...)
}

// AppendedCertificateChain returns the list of values that were appended to the "certificate_chain" field in this mutation.
func (m *CertificateMutation) AppendedCertificateChain() ([]string, bool) {
	if len(m.appendcertificate_chain) == 0 {
		return nil, false
	}
	return m.appendcertificate_chain, true
}

// ClearCertificateChain clears the value of the "certificate_chain" field.
func (m *CertificateMutation) ClearCertificateChain() {
	m.certificate_chain = nil
	m.appendcertificate_chain = nil
	m.clearedFields[certificate.FieldCertificateChain] = struct{}{}
}

// CertificateChainCleared returns if the "certificate_chain" field was cleared in this mutation.
func (m *CertificateMutation) CertificateChainCleared() bool {
	_, ok := m.clearedFields[certificate.FieldCertificateChain]
	return ok
}

// ResetCertificateChain resets all changes to the "certificate_chain" field.
func (m *CertificateMutation) ResetCertificateChain() {
	m.certificate_chain = nil
	m.appendcertificate_chain = nil
	delete(m.clearedFields, certificate.FieldCertificateChain)
}

// SetFingerprint sets the "fingerprint" field.
func (m *CertificateMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *CertificateMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldFingerprint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ClearFingerprint clears the value of the "fingerprint" field.
func (m *CertificateMutation) ClearFingerprint() {
	m.fingerprint = nil
	m.clearedFields[certificate.FieldFingerprint] = struct{}{}
}

// FingerprintCleared returns if the "fingerprint" field was cleared in this mutation.
func (m *CertificateMutation) FingerprintCleared() bool {
	_, ok := m.clearedFields[certificate.FieldFingerprint]
	return ok
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *CertificateMutation) ResetFingerprint() {
	m.fingerprint = nil
	delete(m.clearedFields, certificate.FieldFingerprint)
}

// SetStatus sets the "status" field.
func (m *CertificateMutation) SetStatus(e enum.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *CertificateMutation) Status() (r enum.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldStatus(ctx context.Context) (v enum.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CertificateMutation) ResetStatus() {
	m.status = nil
}

// SetIssuedAt sets the "issued_at" field.
func (m *CertificateMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *CertificateMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldIssuedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ClearIssuedAt clears the value of the "issued_at" field.
func (m *CertificateMutation) ClearIssuedAt() {
	m.issued_at = nil
	m.clearedFields[certificate.FieldIssuedAt] = struct{}{}
}

// IssuedAtCleared returns if the "issued_at" field was cleared in this mutation.
func (m *CertificateMutation) IssuedAtCleared() bool {
	_, ok := m.clearedFields[certificate.FieldIssuedAt]
	return ok
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *CertificateMutation) ResetIssuedAt() {
	m.issued_at = nil
	delete(m.clearedFields, certificate.FieldIssuedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *CertificateMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CertificateMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *CertificateMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[certificate.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *CertificateMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[certificate.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CertificateMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, certificate.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CertificateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CertificateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CertificateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CertificateMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CertificateMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CertificateMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CertificateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CertificateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CertificateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[certificate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CertificateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[certificate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CertificateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, certificate.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CertificateMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CertificateMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldUpdatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CertificateMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[certificate.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CertificateMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[certificate.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CertificateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, certificate.FieldUpdatedBy)
}

// ClearAcmeAccount clears the "acme_account" edge to the AcmeAccount entity.
func (m *CertificateMutation) ClearAcmeAccount() {
	m.clearedacme_account = true
	m.clearedFields[certificate.FieldAcmeAccountID] = struct{}{}
}

// AcmeAccountCleared reports if the "acme_account" edge to the AcmeAccount entity was cleared.
func (m *CertificateMutation) AcmeAccountCleared() bool {
	return m.clearedacme_account
}

// AcmeAccountIDs returns the "acme_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AcmeAccountID instead. It exists only for internal usage by the builders.
func (m *CertificateMutation) AcmeAccountIDs() (ids []uuid.UUID) {
	if id := m.acme_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAcmeAccount resets all changes to the "acme_account" edge.
func (m *CertificateMutation) ResetAcmeAccount() {
	m.acme_account = nil
	m.clearedacme_account = false
}

// ClearDNSProvider clears the "dns_provider" edge to the DnsProvider entity.
func (m *CertificateMutation) ClearDNSProvider() {
	m.cleareddns_provider = true
	m.clearedFields[certificate.FieldDNSProviderID] = struct{}{}
}

// DNSProviderCleared reports if the "dns_provider" edge to the DnsProvider entity was cleared.
func (m *CertificateMutation) DNSProviderCleared() bool {
	return m.cleareddns_provider
}

// DNSProviderIDs returns the "dns_provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DNSProviderID instead. It exists only for internal usage by the builders.
func (m *CertificateMutation) DNSProviderIDs() (ids []uuid.UUID) {
	if id := m.dns_provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDNSProvider resets all changes to the "dns_provider" edge.
func (m *CertificateMutation) ResetDNSProvider() {
	m.dns_provider = nil
	m.cleareddns_provider = false
}

// Where appends a list predicates to the CertificateMutation builder.
func (m *CertificateMutation) Where(ps ...predicate.Certificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.acme_account != nil {
		fields = append(fields, certificate.FieldAcmeAccountID)
	}
	if m.dns_provider != nil {
		fields = append(fields, certificate.FieldDNSProviderID)
	}
	if m.common_name != nil {
		fields = append(fields, certificate.FieldCommonName)
	}
	if m.subject_alternative_name != nil {
		fields = append(fields, certificate.FieldSubjectAlternativeName)
	}
	if m.organization != nil {
		fields = append(fields, certificate.FieldOrganization)
	}
	if m.organizational_unit != nil {
		fields = append(fields, certificate.FieldOrganizationalUnit)
	}
	if m.country != nil {
		fields = append(fields, certificate.FieldCountry)
	}
	if m.state != nil {
		fields = append(fields, certificate.FieldState)
	}
	if m.locality != nil {
		fields = append(fields, certificate.FieldLocality)
	}
	if m.street_address != nil {
		fields = append(fields, certificate.FieldStreetAddress)
	}
	if m.key_type != nil {
		fields = append(fields, certificate.FieldKeyType)
	}
	if m.csr != nil {
		fields = append(fields, certificate.FieldCsr)
	}
	if m.private_key != nil {
		fields = append(fields, certificate.FieldPrivateKey)
	}
	if m.certificate != nil {
		fields = append(fields, certificate.FieldCertificate)
	}
	if m.certificate_chain != nil {
		fields = append(fields, certificate.FieldCertificateChain)
	}
	if m.fingerprint != nil {
		fields = append(fields, certificate.FieldFingerprint)
	}
	if m.status != nil {
		fields = append(fields, certificate.FieldStatus)
	}
	if m.issued_at != nil {
		fields = append(fields, certificate.FieldIssuedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, certificate.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, certificate.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, certificate.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, certificate.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, certificate.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldAcmeAccountID:
		return m.AcmeAccountID()
	case certificate.FieldDNSProviderID:
		return m.DNSProviderID()
	case certificate.FieldCommonName:
		return m.CommonName()
	case certificate.FieldSubjectAlternativeName:
		return m.SubjectAlternativeName()
	case certificate.FieldOrganization:
		return m.Organization()
	case certificate.FieldOrganizationalUnit:
		return m.OrganizationalUnit()
	case certificate.FieldCountry:
		return m.Country()
	case certificate.FieldState:
		return m.State()
	case certificate.FieldLocality:
		return m.Locality()
	case certificate.FieldStreetAddress:
		return m.StreetAddress()
	case certificate.FieldKeyType:
		return m.KeyType()
	case certificate.FieldCsr:
		return m.Csr()
	case certificate.FieldPrivateKey:
		return m.PrivateKey()
	case certificate.FieldCertificate:
		return m.Certificate()
	case certificate.FieldCertificateChain:
		return m.CertificateChain()
	case certificate.FieldFingerprint:
		return m.Fingerprint()
	case certificate.FieldStatus:
		return m.Status()
	case certificate.FieldIssuedAt:
		return m.IssuedAt()
	case certificate.FieldExpiresAt:
		return m.ExpiresAt()
	case certificate.FieldCreatedAt:
		return m.CreatedAt()
	case certificate.FieldCreatedBy:
		return m.CreatedBy()
	case certificate.FieldUpdatedAt:
		return m.UpdatedAt()
	case certificate.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldAcmeAccountID:
		return m.OldAcmeAccountID(ctx)
	case certificate.FieldDNSProviderID:
		return m.OldDNSProviderID(ctx)
	case certificate.FieldCommonName:
		return m.OldCommonName(ctx)
	case certificate.FieldSubjectAlternativeName:
		return m.OldSubjectAlternativeName(ctx)
	case certificate.FieldOrganization:
		return m.OldOrganization(ctx)
	case certificate.FieldOrganizationalUnit:
		return m.OldOrganizationalUnit(ctx)
	case certificate.FieldCountry:
		return m.OldCountry(ctx)
	case certificate.FieldState:
		return m.OldState(ctx)
	case certificate.FieldLocality:
		return m.OldLocality(ctx)
	case certificate.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case certificate.FieldKeyType:
		return m.OldKeyType(ctx)
	case certificate.FieldCsr:
		return m.OldCsr(ctx)
	case certificate.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case certificate.FieldCertificate:
		return m.OldCertificate(ctx)
	case certificate.FieldCertificateChain:
		return m.OldCertificateChain(ctx)
	case certificate.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case certificate.FieldStatus:
		return m.OldStatus(ctx)
	case certificate.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case certificate.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case certificate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case certificate.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case certificate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case certificate.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldAcmeAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcmeAccountID(v)
		return nil
	case certificate.FieldDNSProviderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSProviderID(v)
		return nil
	case certificate.FieldCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonName(v)
		return nil
	case certificate.FieldSubjectAlternativeName:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectAlternativeName(v)
		return nil
	case certificate.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case certificate.FieldOrganizationalUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationalUnit(v)
		return nil
	case certificate.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case certificate.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case certificate.FieldLocality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocality(v)
		return nil
	case certificate.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case certificate.FieldKeyType:
		v, ok := value.(enum.KeyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyType(v)
		return nil
	case certificate.FieldCsr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsr(v)
		return nil
	case certificate.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case certificate.FieldCertificate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificate(v)
		return nil
	case certificate.FieldCertificateChain:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateChain(v)
		return nil
	case certificate.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case certificate.FieldStatus:
		v, ok := value.(enum.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case certificate.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case certificate.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case certificate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case certificate.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case certificate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case certificate.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificate.FieldSubjectAlternativeName) {
		fields = append(fields, certificate.FieldSubjectAlternativeName)
	}
	if m.FieldCleared(certificate.FieldOrganization) {
		fields = append(fields, certificate.FieldOrganization)
	}
	if m.FieldCleared(certificate.FieldOrganizationalUnit) {
		fields = append(fields, certificate.FieldOrganizationalUnit)
	}
	if m.FieldCleared(certificate.FieldCountry) {
		fields = append(fields, certificate.FieldCountry)
	}
	if m.FieldCleared(certificate.FieldState) {
		fields = append(fields, certificate.FieldState)
	}
	if m.FieldCleared(certificate.FieldLocality) {
		fields = append(fields, certificate.FieldLocality)
	}
	if m.FieldCleared(certificate.FieldStreetAddress) {
		fields = append(fields, certificate.FieldStreetAddress)
	}
	if m.FieldCleared(certificate.FieldCsr) {
		fields = append(fields, certificate.FieldCsr)
	}
	if m.FieldCleared(certificate.FieldPrivateKey) {
		fields = append(fields, certificate.FieldPrivateKey)
	}
	if m.FieldCleared(certificate.FieldCertificate) {
		fields = append(fields, certificate.FieldCertificate)
	}
	if m.FieldCleared(certificate.FieldCertificateChain) {
		fields = append(fields, certificate.FieldCertificateChain)
	}
	if m.FieldCleared(certificate.FieldFingerprint) {
		fields = append(fields, certificate.FieldFingerprint)
	}
	if m.FieldCleared(certificate.FieldIssuedAt) {
		fields = append(fields, certificate.FieldIssuedAt)
	}
	if m.FieldCleared(certificate.FieldExpiresAt) {
		fields = append(fields, certificate.FieldExpiresAt)
	}
	if m.FieldCleared(certificate.FieldUpdatedAt) {
		fields = append(fields, certificate.FieldUpdatedAt)
	}
	if m.FieldCleared(certificate.FieldUpdatedBy) {
		fields = append(fields, certificate.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	switch name {
	case certificate.FieldSubjectAlternativeName:
		m.ClearSubjectAlternativeName()
		return nil
	case certificate.FieldOrganization:
		m.ClearOrganization()
		return nil
	case certificate.FieldOrganizationalUnit:
		m.ClearOrganizationalUnit()
		return nil
	case certificate.FieldCountry:
		m.ClearCountry()
		return nil
	case certificate.FieldState:
		m.ClearState()
		return nil
	case certificate.FieldLocality:
		m.ClearLocality()
		return nil
	case certificate.FieldStreetAddress:
		m.ClearStreetAddress()
		return nil
	case certificate.FieldCsr:
		m.ClearCsr()
		return nil
	case certificate.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	case certificate.FieldCertificate:
		m.ClearCertificate()
		return nil
	case certificate.FieldCertificateChain:
		m.ClearCertificateChain()
		return nil
	case certificate.FieldFingerprint:
		m.ClearFingerprint()
		return nil
	case certificate.FieldIssuedAt:
		m.ClearIssuedAt()
		return nil
	case certificate.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case certificate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case certificate.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldAcmeAccountID:
		m.ResetAcmeAccountID()
		return nil
	case certificate.FieldDNSProviderID:
		m.ResetDNSProviderID()
		return nil
	case certificate.FieldCommonName:
		m.ResetCommonName()
		return nil
	case certificate.FieldSubjectAlternativeName:
		m.ResetSubjectAlternativeName()
		return nil
	case certificate.FieldOrganization:
		m.ResetOrganization()
		return nil
	case certificate.FieldOrganizationalUnit:
		m.ResetOrganizationalUnit()
		return nil
	case certificate.FieldCountry:
		m.ResetCountry()
		return nil
	case certificate.FieldState:
		m.ResetState()
		return nil
	case certificate.FieldLocality:
		m.ResetLocality()
		return nil
	case certificate.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case certificate.FieldKeyType:
		m.ResetKeyType()
		return nil
	case certificate.FieldCsr:
		m.ResetCsr()
		return nil
	case certificate.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case certificate.FieldCertificate:
		m.ResetCertificate()
		return nil
	case certificate.FieldCertificateChain:
		m.ResetCertificateChain()
		return nil
	case certificate.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case certificate.FieldStatus:
		m.ResetStatus()
		return nil
	case certificate.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case certificate.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case certificate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case certificate.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case certificate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case certificate.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.acme_account != nil {
		edges = append(edges, certificate.EdgeAcmeAccount)
	}
	if m.dns_provider != nil {
		edges = append(edges, certificate.EdgeDNSProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeAcmeAccount:
		if id := m.acme_account; id != nil {
			return []ent.Value{*id}
		}
	case certificate.EdgeDNSProvider:
		if id := m.dns_provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedacme_account {
		edges = append(edges, certificate.EdgeAcmeAccount)
	}
	if m.cleareddns_provider {
		edges = append(edges, certificate.EdgeDNSProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	switch name {
	case certificate.EdgeAcmeAccount:
		return m.clearedacme_account
	case certificate.EdgeDNSProvider:
		return m.cleareddns_provider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	switch name {
	case certificate.EdgeAcmeAccount:
		m.ClearAcmeAccount()
		return nil
	case certificate.EdgeDNSProvider:
		m.ClearDNSProvider()
		return nil
	}
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	switch name {
	case certificate.EdgeAcmeAccount:
		m.ResetAcmeAccount()
		return nil
	case certificate.EdgeDNSProvider:
		m.ResetDNSProvider()
		return nil
	}
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// DnsProviderMutation represents an operation that mutates the DnsProvider nodes in the graph.
type DnsProviderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	_type               *string
	_config             **lego.DnsProviderConfig
	created_at          *time.Time
	created_by          *uuid.UUID
	updated_at          *time.Time
	updated_by          *uuid.UUID
	clearedFields       map[string]struct{}
	certificates        map[uuid.UUID]struct{}
	removedcertificates map[uuid.UUID]struct{}
	clearedcertificates bool
	done                bool
	oldValue            func(context.Context) (*DnsProvider, error)
	predicates          []predicate.DnsProvider
}

var _ ent.Mutation = (*DnsProviderMutation)(nil)

// dnsproviderOption allows management of the mutation configuration using functional options.
type dnsproviderOption func(*DnsProviderMutation)

// newDnsProviderMutation creates new mutation for the DnsProvider entity.
func newDnsProviderMutation(c config, op Op, opts ...dnsproviderOption) *DnsProviderMutation {
	m := &DnsProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeDnsProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDnsProviderID sets the ID field of the mutation.
func withDnsProviderID(id uuid.UUID) dnsproviderOption {
	return func(m *DnsProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *DnsProvider
		)
		m.oldValue = func(ctx context.Context) (*DnsProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DnsProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDnsProvider sets the old DnsProvider of the mutation.
func withDnsProvider(node *DnsProvider) dnsproviderOption {
	return func(m *DnsProviderMutation) {
		m.oldValue = func(context.Context) (*DnsProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DnsProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DnsProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DnsProvider entities.
func (m *DnsProviderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DnsProviderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DnsProviderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DnsProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DnsProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DnsProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DnsProviderMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DnsProviderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DnsProviderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DnsProviderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dnsprovider.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DnsProviderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dnsprovider.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DnsProviderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dnsprovider.FieldDescription)
}

// SetType sets the "type" field.
func (m *DnsProviderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DnsProviderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DnsProviderMutation) ResetType() {
	m._type = nil
}

// SetConfig sets the "config" field.
func (m *DnsProviderMutation) SetConfig(lpc *lego.DnsProviderConfig) {
	m._config = &lpc
}

// Config returns the value of the "config" field in the mutation.
func (m *DnsProviderMutation) Config() (r *lego.DnsProviderConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldConfig(ctx context.Context) (v *lego.DnsProviderConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DnsProviderMutation) ResetConfig() {
	m._config = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DnsProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DnsProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DnsProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DnsProviderMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DnsProviderMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DnsProviderMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DnsProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DnsProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DnsProviderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dnsprovider.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DnsProviderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dnsprovider.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DnsProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dnsprovider.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DnsProviderMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DnsProviderMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DnsProvider entity.
// If the DnsProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsProviderMutation) OldUpdatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DnsProviderMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[dnsprovider.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DnsProviderMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dnsprovider.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DnsProviderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, dnsprovider.FieldUpdatedBy)
}

// AddCertificateIDs adds the "certificates" edge to the Certificate entity by ids.
func (m *DnsProviderMutation) AddCertificateIDs(ids ...uuid.UUID) {
	if m.certificates == nil {
		m.certificates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certificates[ids[i]] = struct{}{}
	}
}

// ClearCertificates clears the "certificates" edge to the Certificate entity.
func (m *DnsProviderMutation) ClearCertificates() {
	m.clearedcertificates = true
}

// CertificatesCleared reports if the "certificates" edge to the Certificate entity was cleared.
func (m *DnsProviderMutation) CertificatesCleared() bool {
	return m.clearedcertificates
}

// RemoveCertificateIDs removes the "certificates" edge to the Certificate entity by IDs.
func (m *DnsProviderMutation) RemoveCertificateIDs(ids ...uuid.UUID) {
	if m.removedcertificates == nil {
		m.removedcertificates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certificates, ids[i])
		m.removedcertificates[ids[i]] = struct{}{}
	}
}

// RemovedCertificates returns the removed IDs of the "certificates" edge to the Certificate entity.
func (m *DnsProviderMutation) RemovedCertificatesIDs() (ids []uuid.UUID) {
	for id := range m.removedcertificates {
		ids = append(ids, id)
	}
	return
}

// CertificatesIDs returns the "certificates" edge IDs in the mutation.
func (m *DnsProviderMutation) CertificatesIDs() (ids []uuid.UUID) {
	for id := range m.certificates {
		ids = append(ids, id)
	}
	return
}

// ResetCertificates resets all changes to the "certificates" edge.
func (m *DnsProviderMutation) ResetCertificates() {
	m.certificates = nil
	m.clearedcertificates = false
	m.removedcertificates = nil
}

// Where appends a list predicates to the DnsProviderMutation builder.
func (m *DnsProviderMutation) Where(ps ...predicate.DnsProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DnsProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DnsProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DnsProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DnsProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DnsProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DnsProvider).
func (m *DnsProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DnsProviderMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, dnsprovider.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dnsprovider.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, dnsprovider.FieldType)
	}
	if m._config != nil {
		fields = append(fields, dnsprovider.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, dnsprovider.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dnsprovider.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsprovider.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, dnsprovider.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DnsProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsprovider.FieldName:
		return m.Name()
	case dnsprovider.FieldDescription:
		return m.Description()
	case dnsprovider.FieldType:
		return m.GetType()
	case dnsprovider.FieldConfig:
		return m.Config()
	case dnsprovider.FieldCreatedAt:
		return m.CreatedAt()
	case dnsprovider.FieldCreatedBy:
		return m.CreatedBy()
	case dnsprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsprovider.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DnsProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsprovider.FieldName:
		return m.OldName(ctx)
	case dnsprovider.FieldDescription:
		return m.OldDescription(ctx)
	case dnsprovider.FieldType:
		return m.OldType(ctx)
	case dnsprovider.FieldConfig:
		return m.OldConfig(ctx)
	case dnsprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsprovider.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dnsprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsprovider.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown DnsProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DnsProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsprovider.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dnsprovider.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsprovider.FieldConfig:
		v, ok := value.(*lego.DnsProviderConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case dnsprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsprovider.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dnsprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsprovider.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DnsProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DnsProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DnsProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DnsProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DnsProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DnsProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dnsprovider.FieldDescription) {
		fields = append(fields, dnsprovider.FieldDescription)
	}
	if m.FieldCleared(dnsprovider.FieldUpdatedAt) {
		fields = append(fields, dnsprovider.FieldUpdatedAt)
	}
	if m.FieldCleared(dnsprovider.FieldUpdatedBy) {
		fields = append(fields, dnsprovider.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DnsProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DnsProviderMutation) ClearField(name string) error {
	switch name {
	case dnsprovider.FieldDescription:
		m.ClearDescription()
		return nil
	case dnsprovider.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dnsprovider.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown DnsProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DnsProviderMutation) ResetField(name string) error {
	switch name {
	case dnsprovider.FieldName:
		m.ResetName()
		return nil
	case dnsprovider.FieldDescription:
		m.ResetDescription()
		return nil
	case dnsprovider.FieldType:
		m.ResetType()
		return nil
	case dnsprovider.FieldConfig:
		m.ResetConfig()
		return nil
	case dnsprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsprovider.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dnsprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsprovider.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown DnsProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DnsProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.certificates != nil {
		edges = append(edges, dnsprovider.EdgeCertificates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DnsProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsprovider.EdgeCertificates:
		ids := make([]ent.Value, 0, len(m.certificates))
		for id := range m.certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DnsProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcertificates != nil {
		edges = append(edges, dnsprovider.EdgeCertificates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DnsProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dnsprovider.EdgeCertificates:
		ids := make([]ent.Value, 0, len(m.removedcertificates))
		for id := range m.removedcertificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DnsProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcertificates {
		edges = append(edges, dnsprovider.EdgeCertificates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DnsProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsprovider.EdgeCertificates:
		return m.clearedcertificates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DnsProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DnsProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DnsProviderMutation) ResetEdge(name string) error {
	switch name {
	case dnsprovider.EdgeCertificates:
		m.ResetCertificates()
		return nil
	}
	return fmt.Errorf("unknown DnsProvider edge %s", name)
}
