package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"acme-manager/config"
	"acme-manager/ent"
	"acme-manager/graphql/model"
	"context"
	"time"

	"entgo.io/contrib/entgql"
	cerrors "github.com/cockroachdb/errors"
	"github.com/google/uuid"
)

// CreateAcmeAccount is the resolver for the createAcmeAccount field.
func (r *mutationResolver) CreateAcmeAccount(ctx context.Context, input model.CreateAcmeAccountInput) (*ent.AcmeAccount, error) {
	server, err := r.client.AcmeServer.Get(ctx, input.AcmeServerID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find the ACME server")
		}

		return nil, cerrors.WithStack(err)
	}
	registrationInfo, err := registerAcmeAccount(registerAcmeAccountInput{
		CAUrl:                   server.URL,
		Email:                   input.Email,
		KeyType:                 input.KeyType,
		ExternalAccountRequired: server.ExternalAccountRequired,
		EabKeyID:                input.EabKeyID,
		EabHmacKey:              input.EabHmacKey,
	})
	if err != nil {
		return nil, cerrors.WithStack(err)
	}
	create := r.client.AcmeAccount.Create().
		SetAcmeServer(server).
		SetID(uuid.New()).
		SetName(input.Name).
		SetEmail(registrationInfo.Email).
		SetKeyType(input.KeyType).
		SetPrivateKey(registrationInfo.PrivateKey).
		SetKeyFingerprint(registrationInfo.KeyFingerprint).
		SetRegistration(registrationInfo.Registration).
		SetCreatedAt(time.Now()).
		SetCreatedBy(config.SystemUserID)
	if input.Description != nil {
		create.SetDescription(*input.Description)
	}
	if input.EabKeyID != nil {
		create.SetEabKeyID(*input.EabKeyID)
	}
	if input.EabHmacKey != nil {
		create.SetEabHmacKey(*input.EabHmacKey)
	}
	saved, err := create.Save(ctx)
	if err != nil {
		return nil, cerrors.Wrap(err, "failed to save ACME account")
	}
	sensitiveAcmeAccount(saved)
	return saved, nil
}

// UpdateAcmeAccount is the resolver for the updateAcmeAccount field.
func (r *mutationResolver) UpdateAcmeAccount(ctx context.Context, input model.UpdateAcmeAccountInput) (*ent.AcmeAccount, error) {
	exist, err := r.client.AcmeAccount.Get(ctx, input.ID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find ACME account")
		}
		return nil, cerrors.WithStack(err)
	}
	return r.updateAcmeAccount(ctx, input, exist)
}

// UpdateAcmeAccountDangerous is the resolver for the updateAcmeAccountDangerous field.
func (r *mutationResolver) UpdateAcmeAccountDangerous(ctx context.Context, input model.UpdateAcmeAccountDangerousInput) (*ent.AcmeAccount, error) {
	exist, err := r.client.AcmeAccount.Get(ctx, input.ID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find ACME account")
		}
		return nil, cerrors.WithStack(err)
	}
	server, err := r.client.AcmeServer.Get(ctx, input.AcmeServerID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find ACME server")

		}
		return nil, cerrors.WithStack(err)
	}
	if input.Email == exist.Email &&
		input.KeyType == exist.KeyType &&
		input.EabKeyID == exist.EabKeyID &&
		input.EabHmacKey == exist.EabHmacKey &&
		input.AcmeServerID == exist.AcmeServerID {

		return r.updateAcmeAccount(ctx, model.UpdateAcmeAccountInput{
			ID:          input.ID,
			Name:        input.Name,
			Description: input.Description,
		}, exist)
	}

	registrationInfo, err := registerAcmeAccount(registerAcmeAccountInput{
		CAUrl:                   server.URL,
		Email:                   input.Email,
		KeyType:                 input.KeyType,
		ExternalAccountRequired: server.ExternalAccountRequired,
		EabKeyID:                input.EabKeyID,
		EabHmacKey:              input.EabHmacKey,
	})
	if err != nil {
		return nil, cerrors.WithStack(err)
	}
	update := exist.Update().
		SetAcmeServer(server).
		SetName(input.Name).
		SetEmail(registrationInfo.Email).
		SetKeyType(input.KeyType).
		SetPrivateKey(registrationInfo.PrivateKey).
		SetKeyFingerprint(registrationInfo.KeyFingerprint).
		SetRegistration(registrationInfo.Registration).
		SetUpdatedAt(time.Now()).
		SetUpdatedBy(config.SystemUserID)
	if input.Description == nil {
		update.ClearDescription()
	} else {
		update.SetDescription(*input.Description)
	}
	if input.EabKeyID == nil {
		update.ClearEabKeyID()
	} else {
		update.SetEabKeyID(*input.EabKeyID)
	}
	if input.EabHmacKey == nil {
		update.ClearEabHmacKey()
	} else {
		update.SetEabHmacKey(*input.EabHmacKey)
	}
	saved, err := update.Save(ctx)
	if err != nil {
		return nil, cerrors.WithStack(err)
	}
	sensitiveAcmeAccount(saved)
	return saved, nil
}

// DeleteAcmeAccount is the resolver for the deleteAcmeAccount field.
func (r *mutationResolver) DeleteAcmeAccount(ctx context.Context, id uuid.UUID) (bool, error) {
	exist, err := r.client.AcmeAccount.Get(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return false, cerrors.New("cannot find ACME account")
		}
	}
	certificatesCount, err := exist.QueryCertificates().Count(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	if certificatesCount > 0 {
		return false, cerrors.Wrap(err, "this ACME account is used by certificates, cannot delete")
	}
	err = r.client.AcmeAccount.DeleteOne(exist).Exec(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	return true, nil
}

// AcmeAccounts is the resolver for the acmeAccounts field.
func (r *queryResolver) AcmeAccounts(ctx context.Context, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.AcmeAccountOrder) (*ent.AcmeAccountConnection, error) {
	return r.client.AcmeAccount.Query().Paginate(ctx, after, first, before, last, ent.WithAcmeAccountOrder(orderBy))
}

// AcmeAccount is the resolver for the acmeAccount field.
func (r *queryResolver) AcmeAccount(ctx context.Context, id uuid.UUID) (*ent.AcmeAccount, error) {
	return r.client.AcmeAccount.Get(ctx, id)
}
