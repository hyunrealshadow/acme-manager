package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"acme-manager/acme"
	"acme-manager/config"
	"acme-manager/ent"
	"acme-manager/ent/schema/enum"
	"acme-manager/graphql/model"
	"acme-manager/secret"
	"context"
	"time"

	"entgo.io/contrib/entgql"
	cerrors "github.com/cockroachdb/errors"
	"github.com/google/uuid"
)

// CreateCertificate is the resolver for the createCertificate field.
func (r *mutationResolver) CreateCertificate(ctx context.Context, input model.CreateCertificateInput) (*ent.Certificate, error) {
	acmeAccount, err := r.client.AcmeAccount.Get(ctx, input.AcmeAccountID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find ACME account")
		}
		return nil, cerrors.WithStack(err)
	}
	dnsProvider, err := r.client.DnsProvider.Get(ctx, input.DNSProviderID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find DNS provider")
		}
		return nil, cerrors.WithStack(err)
	}
	create := r.client.Certificate.Create()
	create.
		SetID(uuid.New()).
		SetKeyType(input.KeyType).
		SetAcmeAccount(acmeAccount).
		SetDNSProvider(dnsProvider).
		SetCommonName(input.CommonName).
		SetStatus(enum.Pending).
		SetCreatedAt(time.Now()).
		SetCreatedBy(config.SystemUserID)
	if input.SubjectAlternativeName != nil {
		create.SetSubjectAlternativeName(input.SubjectAlternativeName)
	}
	if input.Country != nil {
		create.SetCountry(*input.Country)
	}
	if input.Organization != nil {
		create.SetOrganization(*input.Organization)
	}
	if input.OrganizationalUnit != nil {
		create.SetOrganizationalUnit(*input.OrganizationalUnit)
	}
	if input.State != nil {
		create.SetState(*input.State)
	}
	if input.Locality != nil {
		create.SetLocality(*input.Locality)
	}
	if input.StreetAddress != nil {
		create.SetStreetAddress(*input.StreetAddress)
	}
	return create.Save(ctx)
}

// UpdateCertificate is the resolver for the updateCertificate field.
func (r *mutationResolver) UpdateCertificate(ctx context.Context, input model.UpdateCertificateInput) (*ent.Certificate, error) {
	exist, err := r.client.Certificate.Get(ctx, input.ID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, cerrors.New("cannot find certificate")
		}
		return nil, cerrors.WithStack(err)
	}
	var acmeAccount *ent.AcmeAccount
	if input.AcmeAccountID != nil {
		acmeAccount, err = r.client.AcmeAccount.Get(ctx, *input.AcmeAccountID)
		if err != nil {
			if ent.IsNotFound(err) {
				return nil, cerrors.New("cannot find ACME account")
			}
			return nil, cerrors.WithStack(err)
		}
	}
	var dnsProvider *ent.DnsProvider
	if input.DNSProviderID != nil {
		dnsProvider, err = r.client.DnsProvider.Get(ctx, *input.DNSProviderID)
		if err != nil {
			if ent.IsNotFound(err) {
				return nil, cerrors.New("cannot find DNS provider")
			}
			return nil, cerrors.WithStack(err)
		}
	}
	update := exist.Update().
		ClearCsr().
		ClearCertificate().
		ClearPrivateKey().
		ClearCertificateChain().
		SetStatus(enum.Pending).
		SetUpdatedAt(time.Now()).
		SetUpdatedBy(config.SystemUserID)
	if acmeAccount != nil {
		update.SetAcmeAccount(acmeAccount)
	}
	if dnsProvider != nil {
		update.SetDNSProvider(dnsProvider)
	}
	if input.KeyType != nil {
		update.SetKeyType(*input.KeyType)
	}
	if input.CommonName != nil {
		update.SetCommonName(*input.CommonName)
	}
	if input.SubjectAlternativeName != nil {
		update.SetSubjectAlternativeName(input.SubjectAlternativeName)
	}
	if input.Country != nil {
		update.SetCountry(*input.Country)
	}
	if input.Organization != nil {
		update.SetOrganization(*input.Organization)
	}
	if input.OrganizationalUnit != nil {
		update.SetOrganizationalUnit(*input.OrganizationalUnit)
	}
	if input.State != nil {
		update.SetState(*input.State)
	}
	if input.Locality != nil {
		update.SetLocality(*input.Locality)
	}
	if input.StreetAddress != nil {
		update.SetStreetAddress(*input.StreetAddress)
	}
	return update.Save(ctx)
}

// DeleteCertificate is the resolver for the deleteCertificate field.
func (r *mutationResolver) DeleteCertificate(ctx context.Context, id uuid.UUID) (bool, error) {
	certificate, err := r.client.Certificate.Get(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return false, cerrors.New("cannot find certificate")
		}
		return false, cerrors.WithStack(err)
	}
	err = r.client.Certificate.DeleteOne(certificate).Exec(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	return true, nil
}

// IssueCertificate is the resolver for the issueCertificate field.
func (r *mutationResolver) IssueCertificate(ctx context.Context, id uuid.UUID) (bool, error) {
	certificate, err := r.client.Certificate.Get(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return false, cerrors.New("cannot find certificate")
		}
		return false, cerrors.WithStack(err)
	}
	acmeAccount, err := certificate.QueryAcmeAccount().Only(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	acmeServer, err := acmeAccount.QueryAcmeServer().Only(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	dnsProvider, err := certificate.QueryDNSProvider().Only(ctx)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	decryptedAccountPrivateKey, err := secret.Get().Decrypt(acmeAccount.PrivateKey)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	err = dnsProvider.Config.Decrypt()
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	issueCertificateRequest := acme.IssueCertificateRequest{
		AccountEmail:           acmeAccount.Email,
		AccountPrivateKey:      decryptedAccountPrivateKey,
		AccountRegistration:    acmeAccount.Registration,
		AcmeServerURL:          acmeServer.URL,
		KeyType:                certificate.KeyType,
		DnsProviderType:        dnsProvider.Type,
		DnsProviderConfig:      *dnsProvider.Config,
		CommonName:             certificate.CommonName,
		SubjectAlternativeName: certificate.SubjectAlternativeName,
		Organization:           certificate.Organization,
		OrganizationalUnit:     certificate.OrganizationalUnit,
		Country:                certificate.Country,
		State:                  certificate.State,
		Locality:               certificate.Locality,
		StreetAddress:          certificate.StreetAddress,
	}
	response, err := acme.IssueCertificate(issueCertificateRequest)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	encryptedPrivateKey, err := secret.Get().Encrypt(response.PrivateKey)
	if err != nil {
		return false, cerrors.WithStack(err)
	}
	certificate.Update().
		SetCsr(response.CSR).
		SetCertificate(response.Certificate).
		SetFingerprint(response.Fingerprint).
		SetCertificateChain(response.CertificateChain).
		SetPrivateKey(encryptedPrivateKey).
		SetIssuedAt(response.IssuedAt).
		SetExpiresAt(response.ExpiresAt).
		SetStatus(enum.Succeeded).
		SetUpdatedAt(time.Now()).
		SetUpdatedBy(config.SystemUserID).
		SaveX(ctx)
	return true, nil
}

// Certificates is the resolver for the certificates field.
func (r *queryResolver) Certificates(ctx context.Context, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.CertificateOrder) (*ent.CertificateConnection, error) {
	return r.client.Certificate.Query().Paginate(ctx, after, first, before, last, ent.WithCertificateOrder(orderBy))
}

// Certificate is the resolver for the certificate field.
func (r *queryResolver) Certificate(ctx context.Context, id uuid.UUID) (*ent.Certificate, error) {
	return r.client.Certificate.Get(ctx, id)
}
