// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"acme-manager/ent"
	"acme-manager/graphql/model"
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	DnsProvider() DnsProviderResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Model func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string) (res interface{}, err error)
}

type ComplexityRoot struct {
	AcmeAccount struct {
		AcmeServer     func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		CreatedBy      func(childComplexity int) int
		Description    func(childComplexity int) int
		EabHmacKey     func(childComplexity int) int
		EabKeyID       func(childComplexity int) int
		Email          func(childComplexity int) int
		ID             func(childComplexity int) int
		KeyFingerprint func(childComplexity int) int
		KeyType        func(childComplexity int) int
		Name           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UpdatedBy      func(childComplexity int) int
	}

	AcmeAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AcmeAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AcmeServer struct {
		BuiltIn                 func(childComplexity int) int
		CreatedAt               func(childComplexity int) int
		CreatedBy               func(childComplexity int) int
		Description             func(childComplexity int) int
		ExternalAccountRequired func(childComplexity int) int
		ID                      func(childComplexity int) int
		Name                    func(childComplexity int) int
		URL                     func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		UpdatedBy               func(childComplexity int) int
	}

	AcmeServerConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AcmeServerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Certificate struct {
		AcmeAccount            func(childComplexity int) int
		CommonName             func(childComplexity int) int
		Country                func(childComplexity int) int
		CreatedAt              func(childComplexity int) int
		CreatedBy              func(childComplexity int) int
		DNSProvider            func(childComplexity int) int
		ExpiresAt              func(childComplexity int) int
		Fingerprint            func(childComplexity int) int
		ID                     func(childComplexity int) int
		IssuedAt               func(childComplexity int) int
		KeyType                func(childComplexity int) int
		Locality               func(childComplexity int) int
		Organization           func(childComplexity int) int
		OrganizationalUnit     func(childComplexity int) int
		State                  func(childComplexity int) int
		Status                 func(childComplexity int) int
		StreetAddress          func(childComplexity int) int
		SubjectAlternativeName func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
		UpdatedBy              func(childComplexity int) int
	}

	CertificateConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CertificateEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DnsProvider struct {
		Config      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	DnsProviderConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DnsProviderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateAcmeAccount          func(childComplexity int, input model.CreateAcmeAccountInput) int
		CreateAcmeServer           func(childComplexity int, input model.CreateAcmeServerInput) int
		CreateCertificate          func(childComplexity int, input model.CreateCertificateInput) int
		CreateDNSProvider          func(childComplexity int, input model.CreateDNSProviderInput) int
		DeleteAcmeAccount          func(childComplexity int, id uuid.UUID) int
		DeleteAcmeServer           func(childComplexity int, id uuid.UUID) int
		DeleteCertificate          func(childComplexity int, id uuid.UUID) int
		DeleteDNSProvider          func(childComplexity int, id uuid.UUID) int
		IssueCertificate           func(childComplexity int, id uuid.UUID) int
		UpdateAcmeAccount          func(childComplexity int, input model.UpdateAcmeAccountInput) int
		UpdateAcmeAccountDangerous func(childComplexity int, input model.UpdateAcmeAccountDangerousInput) int
		UpdateAcmeServer           func(childComplexity int, input model.UpdateAcmeServerInput) int
		UpdateAcmeServerDangerous  func(childComplexity int, input model.UpdateAcmeServerDangerousInput) int
		UpdateCertificate          func(childComplexity int, input model.UpdateCertificateInput) int
		UpdateDNSProvider          func(childComplexity int, input model.UpdateDNSProviderInput) int
		UpdateDNSProviderDangerous func(childComplexity int, input model.UpdateDNSProviderDangerousInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		AcmeAccount  func(childComplexity int, id uuid.UUID) int
		AcmeAccounts func(childComplexity int, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.AcmeAccountOrder) int
		AcmeServer   func(childComplexity int, id uuid.UUID) int
		AcmeServers  func(childComplexity int, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.AcmeServerOrder) int
		Certificate  func(childComplexity int, id uuid.UUID) int
		Certificates func(childComplexity int, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.CertificateOrder) int
		DNSProvider  func(childComplexity int, id uuid.UUID) int
		DNSProviders func(childComplexity int, first *int, after *entgql.Cursor[uuid.UUID], last *int, before *entgql.Cursor[uuid.UUID], orderBy *ent.DnsProviderOrder) int
		Node         func(childComplexity int, id uuid.UUID) int
		Nodes        func(childComplexity int, ids []uuid.UUID) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AcmeAccount.acmeServer":
		if e.complexity.AcmeAccount.AcmeServer == nil {
			break
		}

		return e.complexity.AcmeAccount.AcmeServer(childComplexity), true

	case "AcmeAccount.createdAt":
		if e.complexity.AcmeAccount.CreatedAt == nil {
			break
		}

		return e.complexity.AcmeAccount.CreatedAt(childComplexity), true

	case "AcmeAccount.createdBy":
		if e.complexity.AcmeAccount.CreatedBy == nil {
			break
		}

		return e.complexity.AcmeAccount.CreatedBy(childComplexity), true

	case "AcmeAccount.description":
		if e.complexity.AcmeAccount.Description == nil {
			break
		}

		return e.complexity.AcmeAccount.Description(childComplexity), true

	case "AcmeAccount.eabHmacKey":
		if e.complexity.AcmeAccount.EabHmacKey == nil {
			break
		}

		return e.complexity.AcmeAccount.EabHmacKey(childComplexity), true

	case "AcmeAccount.eabKeyID":
		if e.complexity.AcmeAccount.EabKeyID == nil {
			break
		}

		return e.complexity.AcmeAccount.EabKeyID(childComplexity), true

	case "AcmeAccount.email":
		if e.complexity.AcmeAccount.Email == nil {
			break
		}

		return e.complexity.AcmeAccount.Email(childComplexity), true

	case "AcmeAccount.id":
		if e.complexity.AcmeAccount.ID == nil {
			break
		}

		return e.complexity.AcmeAccount.ID(childComplexity), true

	case "AcmeAccount.keyFingerprint":
		if e.complexity.AcmeAccount.KeyFingerprint == nil {
			break
		}

		return e.complexity.AcmeAccount.KeyFingerprint(childComplexity), true

	case "AcmeAccount.keyType":
		if e.complexity.AcmeAccount.KeyType == nil {
			break
		}

		return e.complexity.AcmeAccount.KeyType(childComplexity), true

	case "AcmeAccount.name":
		if e.complexity.AcmeAccount.Name == nil {
			break
		}

		return e.complexity.AcmeAccount.Name(childComplexity), true

	case "AcmeAccount.updatedAt":
		if e.complexity.AcmeAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.AcmeAccount.UpdatedAt(childComplexity), true

	case "AcmeAccount.updatedBy":
		if e.complexity.AcmeAccount.UpdatedBy == nil {
			break
		}

		return e.complexity.AcmeAccount.UpdatedBy(childComplexity), true

	case "AcmeAccountConnection.edges":
		if e.complexity.AcmeAccountConnection.Edges == nil {
			break
		}

		return e.complexity.AcmeAccountConnection.Edges(childComplexity), true

	case "AcmeAccountConnection.pageInfo":
		if e.complexity.AcmeAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.AcmeAccountConnection.PageInfo(childComplexity), true

	case "AcmeAccountConnection.totalCount":
		if e.complexity.AcmeAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.AcmeAccountConnection.TotalCount(childComplexity), true

	case "AcmeAccountEdge.cursor":
		if e.complexity.AcmeAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.AcmeAccountEdge.Cursor(childComplexity), true

	case "AcmeAccountEdge.node":
		if e.complexity.AcmeAccountEdge.Node == nil {
			break
		}

		return e.complexity.AcmeAccountEdge.Node(childComplexity), true

	case "AcmeServer.builtIn":
		if e.complexity.AcmeServer.BuiltIn == nil {
			break
		}

		return e.complexity.AcmeServer.BuiltIn(childComplexity), true

	case "AcmeServer.createdAt":
		if e.complexity.AcmeServer.CreatedAt == nil {
			break
		}

		return e.complexity.AcmeServer.CreatedAt(childComplexity), true

	case "AcmeServer.createdBy":
		if e.complexity.AcmeServer.CreatedBy == nil {
			break
		}

		return e.complexity.AcmeServer.CreatedBy(childComplexity), true

	case "AcmeServer.description":
		if e.complexity.AcmeServer.Description == nil {
			break
		}

		return e.complexity.AcmeServer.Description(childComplexity), true

	case "AcmeServer.externalAccountRequired":
		if e.complexity.AcmeServer.ExternalAccountRequired == nil {
			break
		}

		return e.complexity.AcmeServer.ExternalAccountRequired(childComplexity), true

	case "AcmeServer.id":
		if e.complexity.AcmeServer.ID == nil {
			break
		}

		return e.complexity.AcmeServer.ID(childComplexity), true

	case "AcmeServer.name":
		if e.complexity.AcmeServer.Name == nil {
			break
		}

		return e.complexity.AcmeServer.Name(childComplexity), true

	case "AcmeServer.url":
		if e.complexity.AcmeServer.URL == nil {
			break
		}

		return e.complexity.AcmeServer.URL(childComplexity), true

	case "AcmeServer.updatedAt":
		if e.complexity.AcmeServer.UpdatedAt == nil {
			break
		}

		return e.complexity.AcmeServer.UpdatedAt(childComplexity), true

	case "AcmeServer.updatedBy":
		if e.complexity.AcmeServer.UpdatedBy == nil {
			break
		}

		return e.complexity.AcmeServer.UpdatedBy(childComplexity), true

	case "AcmeServerConnection.edges":
		if e.complexity.AcmeServerConnection.Edges == nil {
			break
		}

		return e.complexity.AcmeServerConnection.Edges(childComplexity), true

	case "AcmeServerConnection.pageInfo":
		if e.complexity.AcmeServerConnection.PageInfo == nil {
			break
		}

		return e.complexity.AcmeServerConnection.PageInfo(childComplexity), true

	case "AcmeServerConnection.totalCount":
		if e.complexity.AcmeServerConnection.TotalCount == nil {
			break
		}

		return e.complexity.AcmeServerConnection.TotalCount(childComplexity), true

	case "AcmeServerEdge.cursor":
		if e.complexity.AcmeServerEdge.Cursor == nil {
			break
		}

		return e.complexity.AcmeServerEdge.Cursor(childComplexity), true

	case "AcmeServerEdge.node":
		if e.complexity.AcmeServerEdge.Node == nil {
			break
		}

		return e.complexity.AcmeServerEdge.Node(childComplexity), true

	case "Certificate.acmeAccount":
		if e.complexity.Certificate.AcmeAccount == nil {
			break
		}

		return e.complexity.Certificate.AcmeAccount(childComplexity), true

	case "Certificate.commonName":
		if e.complexity.Certificate.CommonName == nil {
			break
		}

		return e.complexity.Certificate.CommonName(childComplexity), true

	case "Certificate.country":
		if e.complexity.Certificate.Country == nil {
			break
		}

		return e.complexity.Certificate.Country(childComplexity), true

	case "Certificate.createdAt":
		if e.complexity.Certificate.CreatedAt == nil {
			break
		}

		return e.complexity.Certificate.CreatedAt(childComplexity), true

	case "Certificate.createdBy":
		if e.complexity.Certificate.CreatedBy == nil {
			break
		}

		return e.complexity.Certificate.CreatedBy(childComplexity), true

	case "Certificate.dnsProvider":
		if e.complexity.Certificate.DNSProvider == nil {
			break
		}

		return e.complexity.Certificate.DNSProvider(childComplexity), true

	case "Certificate.expiresAt":
		if e.complexity.Certificate.ExpiresAt == nil {
			break
		}

		return e.complexity.Certificate.ExpiresAt(childComplexity), true

	case "Certificate.fingerprint":
		if e.complexity.Certificate.Fingerprint == nil {
			break
		}

		return e.complexity.Certificate.Fingerprint(childComplexity), true

	case "Certificate.id":
		if e.complexity.Certificate.ID == nil {
			break
		}

		return e.complexity.Certificate.ID(childComplexity), true

	case "Certificate.issuedAt":
		if e.complexity.Certificate.IssuedAt == nil {
			break
		}

		return e.complexity.Certificate.IssuedAt(childComplexity), true

	case "Certificate.keyType":
		if e.complexity.Certificate.KeyType == nil {
			break
		}

		return e.complexity.Certificate.KeyType(childComplexity), true

	case "Certificate.locality":
		if e.complexity.Certificate.Locality == nil {
			break
		}

		return e.complexity.Certificate.Locality(childComplexity), true

	case "Certificate.organization":
		if e.complexity.Certificate.Organization == nil {
			break
		}

		return e.complexity.Certificate.Organization(childComplexity), true

	case "Certificate.organizationalUnit":
		if e.complexity.Certificate.OrganizationalUnit == nil {
			break
		}

		return e.complexity.Certificate.OrganizationalUnit(childComplexity), true

	case "Certificate.state":
		if e.complexity.Certificate.State == nil {
			break
		}

		return e.complexity.Certificate.State(childComplexity), true

	case "Certificate.status":
		if e.complexity.Certificate.Status == nil {
			break
		}

		return e.complexity.Certificate.Status(childComplexity), true

	case "Certificate.streetAddress":
		if e.complexity.Certificate.StreetAddress == nil {
			break
		}

		return e.complexity.Certificate.StreetAddress(childComplexity), true

	case "Certificate.subjectAlternativeName":
		if e.complexity.Certificate.SubjectAlternativeName == nil {
			break
		}

		return e.complexity.Certificate.SubjectAlternativeName(childComplexity), true

	case "Certificate.updatedAt":
		if e.complexity.Certificate.UpdatedAt == nil {
			break
		}

		return e.complexity.Certificate.UpdatedAt(childComplexity), true

	case "Certificate.updatedBy":
		if e.complexity.Certificate.UpdatedBy == nil {
			break
		}

		return e.complexity.Certificate.UpdatedBy(childComplexity), true

	case "CertificateConnection.edges":
		if e.complexity.CertificateConnection.Edges == nil {
			break
		}

		return e.complexity.CertificateConnection.Edges(childComplexity), true

	case "CertificateConnection.pageInfo":
		if e.complexity.CertificateConnection.PageInfo == nil {
			break
		}

		return e.complexity.CertificateConnection.PageInfo(childComplexity), true

	case "CertificateConnection.totalCount":
		if e.complexity.CertificateConnection.TotalCount == nil {
			break
		}

		return e.complexity.CertificateConnection.TotalCount(childComplexity), true

	case "CertificateEdge.cursor":
		if e.complexity.CertificateEdge.Cursor == nil {
			break
		}

		return e.complexity.CertificateEdge.Cursor(childComplexity), true

	case "CertificateEdge.node":
		if e.complexity.CertificateEdge.Node == nil {
			break
		}

		return e.complexity.CertificateEdge.Node(childComplexity), true

	case "DnsProvider.config":
		if e.complexity.DnsProvider.Config == nil {
			break
		}

		return e.complexity.DnsProvider.Config(childComplexity), true

	case "DnsProvider.createdAt":
		if e.complexity.DnsProvider.CreatedAt == nil {
			break
		}

		return e.complexity.DnsProvider.CreatedAt(childComplexity), true

	case "DnsProvider.createdBy":
		if e.complexity.DnsProvider.CreatedBy == nil {
			break
		}

		return e.complexity.DnsProvider.CreatedBy(childComplexity), true

	case "DnsProvider.description":
		if e.complexity.DnsProvider.Description == nil {
			break
		}

		return e.complexity.DnsProvider.Description(childComplexity), true

	case "DnsProvider.id":
		if e.complexity.DnsProvider.ID == nil {
			break
		}

		return e.complexity.DnsProvider.ID(childComplexity), true

	case "DnsProvider.name":
		if e.complexity.DnsProvider.Name == nil {
			break
		}

		return e.complexity.DnsProvider.Name(childComplexity), true

	case "DnsProvider.type":
		if e.complexity.DnsProvider.Type == nil {
			break
		}

		return e.complexity.DnsProvider.Type(childComplexity), true

	case "DnsProvider.updatedAt":
		if e.complexity.DnsProvider.UpdatedAt == nil {
			break
		}

		return e.complexity.DnsProvider.UpdatedAt(childComplexity), true

	case "DnsProvider.updatedBy":
		if e.complexity.DnsProvider.UpdatedBy == nil {
			break
		}

		return e.complexity.DnsProvider.UpdatedBy(childComplexity), true

	case "DnsProviderConnection.edges":
		if e.complexity.DnsProviderConnection.Edges == nil {
			break
		}

		return e.complexity.DnsProviderConnection.Edges(childComplexity), true

	case "DnsProviderConnection.pageInfo":
		if e.complexity.DnsProviderConnection.PageInfo == nil {
			break
		}

		return e.complexity.DnsProviderConnection.PageInfo(childComplexity), true

	case "DnsProviderConnection.totalCount":
		if e.complexity.DnsProviderConnection.TotalCount == nil {
			break
		}

		return e.complexity.DnsProviderConnection.TotalCount(childComplexity), true

	case "DnsProviderEdge.cursor":
		if e.complexity.DnsProviderEdge.Cursor == nil {
			break
		}

		return e.complexity.DnsProviderEdge.Cursor(childComplexity), true

	case "DnsProviderEdge.node":
		if e.complexity.DnsProviderEdge.Node == nil {
			break
		}

		return e.complexity.DnsProviderEdge.Node(childComplexity), true

	case "Mutation.createAcmeAccount":
		if e.complexity.Mutation.CreateAcmeAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createAcmeAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAcmeAccount(childComplexity, args["input"].(model.CreateAcmeAccountInput)), true

	case "Mutation.createAcmeServer":
		if e.complexity.Mutation.CreateAcmeServer == nil {
			break
		}

		args, err := ec.field_Mutation_createAcmeServer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAcmeServer(childComplexity, args["input"].(model.CreateAcmeServerInput)), true

	case "Mutation.createCertificate":
		if e.complexity.Mutation.CreateCertificate == nil {
			break
		}

		args, err := ec.field_Mutation_createCertificate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCertificate(childComplexity, args["input"].(model.CreateCertificateInput)), true

	case "Mutation.createDnsProvider":
		if e.complexity.Mutation.CreateDNSProvider == nil {
			break
		}

		args, err := ec.field_Mutation_createDnsProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDNSProvider(childComplexity, args["input"].(model.CreateDNSProviderInput)), true

	case "Mutation.deleteAcmeAccount":
		if e.complexity.Mutation.DeleteAcmeAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAcmeAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAcmeAccount(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.deleteAcmeServer":
		if e.complexity.Mutation.DeleteAcmeServer == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAcmeServer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAcmeServer(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.deleteCertificate":
		if e.complexity.Mutation.DeleteCertificate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCertificate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCertificate(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.deleteDnsProvider":
		if e.complexity.Mutation.DeleteDNSProvider == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDnsProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDNSProvider(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.issueCertificate":
		if e.complexity.Mutation.IssueCertificate == nil {
			break
		}

		args, err := ec.field_Mutation_issueCertificate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IssueCertificate(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.updateAcmeAccount":
		if e.complexity.Mutation.UpdateAcmeAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateAcmeAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAcmeAccount(childComplexity, args["input"].(model.UpdateAcmeAccountInput)), true

	case "Mutation.updateAcmeAccountDangerous":
		if e.complexity.Mutation.UpdateAcmeAccountDangerous == nil {
			break
		}

		args, err := ec.field_Mutation_updateAcmeAccountDangerous_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAcmeAccountDangerous(childComplexity, args["input"].(model.UpdateAcmeAccountDangerousInput)), true

	case "Mutation.updateAcmeServer":
		if e.complexity.Mutation.UpdateAcmeServer == nil {
			break
		}

		args, err := ec.field_Mutation_updateAcmeServer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAcmeServer(childComplexity, args["input"].(model.UpdateAcmeServerInput)), true

	case "Mutation.updateAcmeServerDangerous":
		if e.complexity.Mutation.UpdateAcmeServerDangerous == nil {
			break
		}

		args, err := ec.field_Mutation_updateAcmeServerDangerous_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAcmeServerDangerous(childComplexity, args["input"].(model.UpdateAcmeServerDangerousInput)), true

	case "Mutation.updateCertificate":
		if e.complexity.Mutation.UpdateCertificate == nil {
			break
		}

		args, err := ec.field_Mutation_updateCertificate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCertificate(childComplexity, args["input"].(model.UpdateCertificateInput)), true

	case "Mutation.updateDnsProvider":
		if e.complexity.Mutation.UpdateDNSProvider == nil {
			break
		}

		args, err := ec.field_Mutation_updateDnsProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDNSProvider(childComplexity, args["input"].(model.UpdateDNSProviderInput)), true

	case "Mutation.updateDnsProviderDangerous":
		if e.complexity.Mutation.UpdateDNSProviderDangerous == nil {
			break
		}

		args, err := ec.field_Mutation_updateDnsProviderDangerous_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDNSProviderDangerous(childComplexity, args["input"].(model.UpdateDNSProviderDangerousInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.acmeAccount":
		if e.complexity.Query.AcmeAccount == nil {
			break
		}

		args, err := ec.field_Query_acmeAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AcmeAccount(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.acmeAccounts":
		if e.complexity.Query.AcmeAccounts == nil {
			break
		}

		args, err := ec.field_Query_acmeAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AcmeAccounts(childComplexity, args["first"].(*int), args["after"].(*entgql.Cursor[uuid.UUID]), args["last"].(*int), args["before"].(*entgql.Cursor[uuid.UUID]), args["orderBy"].(*ent.AcmeAccountOrder)), true

	case "Query.acmeServer":
		if e.complexity.Query.AcmeServer == nil {
			break
		}

		args, err := ec.field_Query_acmeServer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AcmeServer(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.acmeServers":
		if e.complexity.Query.AcmeServers == nil {
			break
		}

		args, err := ec.field_Query_acmeServers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AcmeServers(childComplexity, args["first"].(*int), args["after"].(*entgql.Cursor[uuid.UUID]), args["last"].(*int), args["before"].(*entgql.Cursor[uuid.UUID]), args["orderBy"].(*ent.AcmeServerOrder)), true

	case "Query.certificate":
		if e.complexity.Query.Certificate == nil {
			break
		}

		args, err := ec.field_Query_certificate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Certificate(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.certificates":
		if e.complexity.Query.Certificates == nil {
			break
		}

		args, err := ec.field_Query_certificates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Certificates(childComplexity, args["first"].(*int), args["after"].(*entgql.Cursor[uuid.UUID]), args["last"].(*int), args["before"].(*entgql.Cursor[uuid.UUID]), args["orderBy"].(*ent.CertificateOrder)), true

	case "Query.dnsProvider":
		if e.complexity.Query.DNSProvider == nil {
			break
		}

		args, err := ec.field_Query_dnsProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DNSProvider(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.dnsProviders":
		if e.complexity.Query.DNSProviders == nil {
			break
		}

		args, err := ec.field_Query_dnsProviders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DNSProviders(childComplexity, args["first"].(*int), args["after"].(*entgql.Cursor[uuid.UUID]), args["last"].(*int), args["before"].(*entgql.Cursor[uuid.UUID]), args["orderBy"].(*ent.DnsProviderOrder)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]uuid.UUID)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAcmeAccountOrder,
		ec.unmarshalInputAcmeServerOrder,
		ec.unmarshalInputCertificateOrder,
		ec.unmarshalInputCreateAcmeAccountInput,
		ec.unmarshalInputCreateAcmeServerInput,
		ec.unmarshalInputCreateCertificateInput,
		ec.unmarshalInputCreateDnsProviderInput,
		ec.unmarshalInputDnsProviderOrder,
		ec.unmarshalInputUpdateAcmeAccountDangerousInput,
		ec.unmarshalInputUpdateAcmeAccountInput,
		ec.unmarshalInputUpdateAcmeServerDangerousInput,
		ec.unmarshalInputUpdateAcmeServerInput,
		ec.unmarshalInputUpdateCertificateInput,
		ec.unmarshalInputUpdateDnsProviderDangerousInput,
		ec.unmarshalInputUpdateDnsProviderInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type AcmeAccount implements Node {
  id: ID! @model(name: "AcmeAccount")
  """
  Name of the ACME account
  """
  name: String!
  """
  Description of the ACME account
  """
  description: String
  """
  Email address associated with the ACME account
  """
  email: String!
  """
  Type of private key associated with the ACME account
  """
  keyType: KeyType!
  """
  Fingerprint of the private key associated with the ACME account
  """
  keyFingerprint: String!
  """
  External Account Binding (EAB) key ID
  """
  eabKeyID: String
  """
  External Account Binding (EAB) HMAC key
  """
  eabHmacKey: String
  """
  Time the ACME account was created
  """
  createdAt: Time!
  """
  User that created the ACME account
  """
  createdBy: ID! @model(name: "User")
  """
  Time the ACME account was updated
  """
  updatedAt: Time
  """
  User that updated the ACME account
  """
  updatedBy: ID @model(name: "User")
  """
  ACME server associated with the ACME account
  """
  acmeServer: AcmeServer!
}
"""
A connection to a list of items.
"""
type AcmeAccountConnection {
  """
  A list of edges.
  """
  edges: [AcmeAccountEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type AcmeAccountEdge {
  """
  The item at the end of the edge.
  """
  node: AcmeAccount
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for AcmeAccount connections
"""
input AcmeAccountOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order AcmeAccounts.
  """
  field: AcmeAccountOrderField!
}
"""
Properties by which AcmeAccount connections can be ordered.
"""
enum AcmeAccountOrderField {
  CREATED_AT
}
type AcmeServer implements Node {
  id: ID! @model(name: "AcmeServer")
  """
  Name of the ACME server
  """
  name: String!
  """
  Description of the ACME server
  """
  description: String
  """
  URL of the ACME server
  """
  url: String!
  """
  Is this a built-in ACME server
  """
  builtIn: Boolean!
  """
  Does the ACME server require an External Account Binding
  """
  externalAccountRequired: Boolean!
  """
  Time the ACME server was created
  """
  createdAt: Time!
  """
  User that created the ACME server
  """
  createdBy: ID! @model(name: "User")
  """
  Time the ACME server was updated
  """
  updatedAt: Time
  """
  User that updated the ACME server
  """
  updatedBy: ID @model(name: "User")
}
"""
A connection to a list of items.
"""
type AcmeServerConnection {
  """
  A list of edges.
  """
  edges: [AcmeServerEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type AcmeServerEdge {
  """
  The item at the end of the edge.
  """
  node: AcmeServer
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for AcmeServer connections
"""
input AcmeServerOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order AcmeServers.
  """
  field: AcmeServerOrderField!
}
"""
Properties by which AcmeServer connections can be ordered.
"""
enum AcmeServerOrderField {
  CREATED_AT
}
type Certificate implements Node {
  id: ID! @model(name: "Certificate")
  """
  Common name of the certificate
  """
  commonName: String!
  """
  Subject alternative name of the certificate
  """
  subjectAlternativeName: [String!]
  """
  Organization name of the certificate
  """
  organization: String
  """
  Organizational unit name of the certificate
  """
  organizationalUnit: String
  """
  Country code of the certificate
  """
  country: String
  """
  State or province of the certificate
  """
  state: String
  """
  Locality of the certificate
  """
  locality: String
  """
  Street address of the certificate
  """
  streetAddress: String
  """
  Key type of the certificate
  """
  keyType: KeyType!
  """
  Fingerprint of the certificate
  """
  fingerprint: String
  """
  Status of the certificate
  """
  status: Status!
  """
  Time the certificate was issued
  """
  issuedAt: Time
  """
  Time the certificate expires
  """
  expiresAt: Time
  """
  Time the certificate was created
  """
  createdAt: Time!
  """
  User that created the certificate
  """
  createdBy: ID! @model(name: "User")
  """
  Time the certificate was updated
  """
  updatedAt: Time
  """
  User that updated the certificate
  """
  updatedBy: ID @model(name: "User")
  acmeAccount: AcmeAccount!
  dnsProvider: DnsProvider!
}
"""
A connection to a list of items.
"""
type CertificateConnection {
  """
  A list of edges.
  """
  edges: [CertificateEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type CertificateEdge {
  """
  The item at the end of the edge.
  """
  node: Certificate
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Certificate connections
"""
input CertificateOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Certificates.
  """
  field: CertificateOrderField!
}
"""
Properties by which Certificate connections can be ordered.
"""
enum CertificateOrderField {
  CREATED_AT
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type DnsProvider implements Node {
  id: ID! @model(name: "DnsProvider")
  """
  Name of the DNS provider
  """
  name: String!
  """
  Description of the DNS provider
  """
  description: String
  """
  Type of the DNS provider
  """
  type: String!
  """
  Configuration of the DNS provider
  """
  config: String!
  """
  Time the DNS provider was created
  """
  createdAt: Time!
  """
  User that created the ACME account
  """
  createdBy: ID! @model(name: "User")
  """
  Time the DNS provider was updated
  """
  updatedAt: Time
  """
  User that updated the ACME account
  """
  updatedBy: ID @model(name: "User")
}
"""
A connection to a list of items.
"""
type DnsProviderConnection {
  """
  A list of edges.
  """
  edges: [DnsProviderEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type DnsProviderEdge {
  """
  The item at the end of the edge.
  """
  node: DnsProvider
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for DnsProvider connections
"""
input DnsProviderOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order DnsProviders.
  """
  field: DnsProviderOrderField!
}
"""
Properties by which DnsProvider connections can be ordered.
"""
enum DnsProviderOrderField {
  CREATED_AT
}
"""
KeyType is enum for the field key_type
"""
enum KeyType @goModel(model: "acme-manager/ent/schema/enum.KeyType") {
  RSA2048
  RSA3072
  RSA4096
  RSA8192
  EC256
  EC384
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "acme-manager/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
"""
Status is enum for the field status
"""
enum Status @goModel(model: "acme-manager/ent/schema/enum.Status") {
  Pending
  Succeeded
  Failed
}
"""
The builtin Time type
"""
scalar Time
`, BuiltIn: false},
	{Name: "../schema/directive.graphql", Input: `directive @model(name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/acme_server.graphql", Input: `"""
CreateAcmeServerInput is used for create AcmeServer object.
"""
input CreateAcmeServerInput {
    """
    Name of the ACME server
    """
    name: String!
    """
    Description of the ACME server
    """
    description: String
    """
    URL of the ACME server
    """
    url: String!
}

"""
UpdateAcmeServerInput is used for update AcmeServer object.
"""
input UpdateAcmeServerInput {
    """
    ID of the ACME server
    """
    id: ID! @model(name: "AcmeServer")
    """
    Name of the ACME server
    """
    name: String!
    """
    Description of the ACME server
    """
    description: String
}

"""
UpdateAcmeServerDangerousInput is used for update AcmeServer object.
"""
input UpdateAcmeServerDangerousInput {
    """
    ID of the ACME server
    """
    id: ID! @model(name: "AcmeServer")
    """
    Name of the ACME server
    """
    name: String!
    """
    Description of the ACME server
    """
    description: String
    """
    URL of the ACME server
    """
    url: String!
}

type Mutation {
    """
    Create a new ACME server
    """
    createAcmeServer(input: CreateAcmeServerInput!): AcmeServer!

    """
    Update an existing ACME server
    """
    updateAcmeServer(input: UpdateAcmeServerInput!): AcmeServer!

    """
    Dangerously update an existing ACME server
    It may cause the ACME server to not be working properly
    """
    updateAcmeServerDangerous(input: UpdateAcmeServerDangerousInput!): AcmeServer!

    """
    Delete an existing ACME server
    """
    deleteAcmeServer(id: ID!): Boolean!
}

extend type Query {
    """
    Get a list of all ACME servers
    """
    acmeServers(first: Int, after: Cursor, last: Int, before: Cursor, orderBy: AcmeServerOrder): AcmeServerConnection!

    """
    Get a specific ACME server by ID
    """
    acmeServer(id: ID! @model(name: "AcmeServer")): AcmeServer!
}
`, BuiltIn: false},
	{Name: "../schema/acme_account.graphql", Input: `"""
CreateAcmeAccountInput is used for create AcmeAccount object.
"""
input CreateAcmeAccountInput {
    """
    Name of the ACME account
    """
    name: String!
    """
    Description of the ACME account
    """
    description: String
    """
    Email address associated with the ACME account
    """
    email: String!
    """
    Type of private key associated with the ACME account
    """
    keyType: KeyType!
    """
    External Account Binding (EAB) key ID
    """
    eabKeyID: String
    """
    External Account Binding (EAB) HMAC key
    """
    eabHmacKey: String
    """
    The ID of the ACME server associated with the account
    """
    acmeServerID: ID!
}

"""
UpdateAcmeAccountInput is used for update AcmeAccount object.
"""
input UpdateAcmeAccountInput {
    """
    ID of the ACME account
    """
    id: ID! @model(name: "AcmeAccount")
    """
    Name of the ACME account
    """
    name: String!
    """
    Description of the ACME account
    """
    description: String
}

"""
UpdateAcmeAccountDangerousInput is used for update AcmeAccount object.
"""
input UpdateAcmeAccountDangerousInput {
    """
    ID of the ACME account
    """
    id: ID! @model(name: "AcmeAccount")
    """
    Name of the ACME account
    """
    name: String!
    """
    Description of the ACME account
    """
    description: String
    """
    Email address associated with the ACME account
    """
    email: String!
    """
    Type of private key associated with the ACME account
    """
    keyType: KeyType!
    """
    External Account Binding (EAB) key ID
    """
    eabKeyID: String
    """
    External Account Binding (EAB) HMAC key
    """
    eabHmacKey: String
    """
    The ID of the ACME server associated with the account
    """
    acmeServerID: ID!
}

extend type Mutation {
    """
    Create a new ACME account
    """
    createAcmeAccount(input: CreateAcmeAccountInput!): AcmeAccount!

    """
    Update an existing ACME account
    """
    updateAcmeAccount(input: UpdateAcmeAccountInput!): AcmeAccount!

    """
    Dangerous Update an existing ACME account
    It may cause the ACME account to be re-registered with the ACME server
    """
    updateAcmeAccountDangerous(input: UpdateAcmeAccountDangerousInput!): AcmeAccount!

    """
    Delete an existing ACME account
    """
    deleteAcmeAccount(id: ID! @model(name: "AcmeAccount")): Boolean!
}

extend type Query {
    """
    Get a list of all ACME accounts
    """
    acmeAccounts(first: Int, after: Cursor, last: Int, before: Cursor, orderBy: AcmeAccountOrder): AcmeAccountConnection!

    """
    Get a specific ACME account by ID
    """
    acmeAccount(id: ID! @model(name: "AcmeAccount")): AcmeAccount!
}
`, BuiltIn: false},
	{Name: "../schema/dns_provider.graphql", Input: `"""
CreateDnsProviderInput is used for create DnsProvider object.
"""
input CreateDnsProviderInput {
    """
    Name of the DNS provider
    """
    name: String!
    """
    Description of the DNS provider
    """
    description: String
    """
    Type of the DNS provider
    """
    type: String!
    """
    Configuration of the DNS provider
    """
    config: String!
}

"""
UpdateDnsProviderInput is used for update DnsProvider object.
"""
input UpdateDnsProviderInput {
    """
    ID of the DNS provider
    """
    id: ID! @model(name: "DnsProvider")
    """
    Name of the DNS provider
    """
    name: String!
    """
    Description of the DNS provider
    """
    description: String
}

"""
Dangerously update an existing DNS provider
It may cause the DNS provider to not be working properly
"""
input UpdateDnsProviderDangerousInput {
    """
    ID of the DNS provider
    """
    id: ID! @model(name: "DnsProvider")
    """
    Name of the DNS provider
    """
    name: String!
    """
    Description of the DNS provider
    """
    description: String
    """
    Type of the DNS provider
    """
    type: String!
    """
    Configuration of the DNS provider
    """
    config: String!
}

extend type Mutation {
    """
    Create a new DNS provider
    """
    createDnsProvider(input: CreateDnsProviderInput!): DnsProvider!
    """
    Update an existing DNS provider
    """
    updateDnsProvider(input: UpdateDnsProviderInput!): DnsProvider!
    """
    Dangerously update an existing DNS provider
    """
    updateDnsProviderDangerous(input: UpdateDnsProviderDangerousInput!): DnsProvider
    """
    Delete an existing DNS provider
    """
    deleteDnsProvider(id: ID! @model(name: "DnsProvider")): Boolean!
}

extend type Query {
    """
    Get a list of all DNS providers
    """
    dnsProviders(first: Int, after: Cursor, last: Int, before: Cursor, orderBy: DnsProviderOrder): DnsProviderConnection!
    """
    Get a specific DNS provider by ID
    """
    dnsProvider(id: ID! @model(name: "DnsProvider")): DnsProvider
}
`, BuiltIn: false},
	{Name: "../schema/certificate.graphql", Input: `"""
CreateCertificateInput is used for create Certificate object.
"""
input CreateCertificateInput {
    """
    Common name of the certificate
    """
    commonName: String!
    """
    Subject alternative name of the certificate
    """
    subjectAlternativeName: [String!]
    """
    Organization name of the certificate
    """
    organization: String
    """
    Organizational unit name of the certificate
    """
    organizationalUnit: String
    """
    Country code of the certificate
    """
    country: String
    """
    State or province of the certificate
    """
    state: String
    """
    Locality of the certificate
    """
    locality: String
    """
    Street address of the certificate
    """
    streetAddress: String
    """
    Key type of the certificate
    """
    keyType: KeyType!
    acmeAccountID: ID!
    dnsProviderID: ID!
}

"""
UpdateCertificateInput is used for update Certificate object.
"""
input UpdateCertificateInput {
    id: ID! @model(name: "Certificate")
    """
    Common name of the certificate
    """
    commonName: String
    """
    Subject alternative name of the certificate
    """
    subjectAlternativeName: [String!]
    """
    Organization name of the certificate
    """
    organization: String
    """
    Organizational unit name of the certificate
    """
    organizationalUnit: String
    """
    Country code of the certificate
    """
    country: String
    """
    State or province of the certificate
    """
    state: String
    """
    Locality of the certificate
    """
    locality: String
    """
    Street address of the certificate
    """
    streetAddress: String
    """
    Key type of the certificate
    """
    keyType: KeyType
    acmeAccountID: ID @model(name: "AcmeAccount")
    dnsProviderID: ID @model(name: "DnsProvider")
}

extend type Mutation {
    """
    Create a new certificate
    """
    createCertificate(input: CreateCertificateInput!): Certificate!
    """
    Update an existing certificate
    This will trigger the issuance of a new certificate
    """
    updateCertificate(input: UpdateCertificateInput!): Certificate!
    """
    Delete a certificate
    """
    deleteCertificate(id: ID! @model(name: "Certificate")): Boolean!
    """
    Issue a certificate
    """
    issueCertificate(id: ID! @model(name: "Certificate")): Boolean!
}

extend type Query {
    """
    Get a list of all certificates
    """
    certificates(first: Int, after: Cursor, last: Int, before: Cursor, orderBy: CertificateOrder): CertificateConnection!
    """
    Get a specific certificate by ID
    """
    certificate(id: ID! @model(name: "Certificate")): Certificate
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
